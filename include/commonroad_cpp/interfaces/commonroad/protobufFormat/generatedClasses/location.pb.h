// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: location.proto

#ifndef PROTOBUF_INCLUDED_location_2eproto
#define PROTOBUF_INCLUDED_location_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "util.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_location_2eproto 

namespace protobuf_location_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_location_2eproto
namespace commonroad {
class Environment;
class EnvironmentDefaultTypeInternal;
extern EnvironmentDefaultTypeInternal _Environment_default_instance_;
class GeoTransformation;
class GeoTransformationDefaultTypeInternal;
extern GeoTransformationDefaultTypeInternal _GeoTransformation_default_instance_;
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class TimeOfDayEnum;
class TimeOfDayEnumDefaultTypeInternal;
extern TimeOfDayEnumDefaultTypeInternal _TimeOfDayEnum_default_instance_;
class UndergroundEnum;
class UndergroundEnumDefaultTypeInternal;
extern UndergroundEnumDefaultTypeInternal _UndergroundEnum_default_instance_;
class WeatherEnum;
class WeatherEnumDefaultTypeInternal;
extern WeatherEnumDefaultTypeInternal _WeatherEnum_default_instance_;
}  // namespace commonroad
namespace google {
namespace protobuf {
template<> ::commonroad::Environment* Arena::CreateMaybeMessage<::commonroad::Environment>(Arena*);
template<> ::commonroad::GeoTransformation* Arena::CreateMaybeMessage<::commonroad::GeoTransformation>(Arena*);
template<> ::commonroad::Location* Arena::CreateMaybeMessage<::commonroad::Location>(Arena*);
template<> ::commonroad::TimeOfDayEnum* Arena::CreateMaybeMessage<::commonroad::TimeOfDayEnum>(Arena*);
template<> ::commonroad::UndergroundEnum* Arena::CreateMaybeMessage<::commonroad::UndergroundEnum>(Arena*);
template<> ::commonroad::WeatherEnum* Arena::CreateMaybeMessage<::commonroad::WeatherEnum>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace commonroad {

enum TimeOfDayEnum_TimeOfDay {
  TimeOfDayEnum_TimeOfDay_NIGHT = 0,
  TimeOfDayEnum_TimeOfDay_DAY = 1,
  TimeOfDayEnum_TimeOfDay_UNKNOWN = 2
};
bool TimeOfDayEnum_TimeOfDay_IsValid(int value);
const TimeOfDayEnum_TimeOfDay TimeOfDayEnum_TimeOfDay_TimeOfDay_MIN = TimeOfDayEnum_TimeOfDay_NIGHT;
const TimeOfDayEnum_TimeOfDay TimeOfDayEnum_TimeOfDay_TimeOfDay_MAX = TimeOfDayEnum_TimeOfDay_UNKNOWN;
const int TimeOfDayEnum_TimeOfDay_TimeOfDay_ARRAYSIZE = TimeOfDayEnum_TimeOfDay_TimeOfDay_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeOfDayEnum_TimeOfDay_descriptor();
inline const ::std::string& TimeOfDayEnum_TimeOfDay_Name(TimeOfDayEnum_TimeOfDay value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeOfDayEnum_TimeOfDay_descriptor(), value);
}
inline bool TimeOfDayEnum_TimeOfDay_Parse(
    const ::std::string& name, TimeOfDayEnum_TimeOfDay* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeOfDayEnum_TimeOfDay>(
    TimeOfDayEnum_TimeOfDay_descriptor(), name, value);
}
enum WeatherEnum_Weather {
  WeatherEnum_Weather_SUNNY = 0,
  WeatherEnum_Weather_LIGHT_RAIN = 1,
  WeatherEnum_Weather_HEAVY_AIN = 2,
  WeatherEnum_Weather_FOG = 3,
  WeatherEnum_Weather_SNOW = 4,
  WeatherEnum_Weather_HAIL = 5,
  WeatherEnum_Weather_UNKNOWN = 6
};
bool WeatherEnum_Weather_IsValid(int value);
const WeatherEnum_Weather WeatherEnum_Weather_Weather_MIN = WeatherEnum_Weather_SUNNY;
const WeatherEnum_Weather WeatherEnum_Weather_Weather_MAX = WeatherEnum_Weather_UNKNOWN;
const int WeatherEnum_Weather_Weather_ARRAYSIZE = WeatherEnum_Weather_Weather_MAX + 1;

const ::google::protobuf::EnumDescriptor* WeatherEnum_Weather_descriptor();
inline const ::std::string& WeatherEnum_Weather_Name(WeatherEnum_Weather value) {
  return ::google::protobuf::internal::NameOfEnum(
    WeatherEnum_Weather_descriptor(), value);
}
inline bool WeatherEnum_Weather_Parse(
    const ::std::string& name, WeatherEnum_Weather* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WeatherEnum_Weather>(
    WeatherEnum_Weather_descriptor(), name, value);
}
enum UndergroundEnum_Underground {
  UndergroundEnum_Underground_WET = 0,
  UndergroundEnum_Underground_CLEAN = 1,
  UndergroundEnum_Underground_DIRTY = 2,
  UndergroundEnum_Underground_DAMAGED = 3,
  UndergroundEnum_Underground_SNOW = 4,
  UndergroundEnum_Underground_ICE = 5,
  UndergroundEnum_Underground_UNKNOWN = 6
};
bool UndergroundEnum_Underground_IsValid(int value);
const UndergroundEnum_Underground UndergroundEnum_Underground_Underground_MIN = UndergroundEnum_Underground_WET;
const UndergroundEnum_Underground UndergroundEnum_Underground_Underground_MAX = UndergroundEnum_Underground_UNKNOWN;
const int UndergroundEnum_Underground_Underground_ARRAYSIZE = UndergroundEnum_Underground_Underground_MAX + 1;

const ::google::protobuf::EnumDescriptor* UndergroundEnum_Underground_descriptor();
inline const ::std::string& UndergroundEnum_Underground_Name(UndergroundEnum_Underground value) {
  return ::google::protobuf::internal::NameOfEnum(
    UndergroundEnum_Underground_descriptor(), value);
}
inline bool UndergroundEnum_Underground_Parse(
    const ::std::string& name, UndergroundEnum_Underground* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UndergroundEnum_Underground>(
    UndergroundEnum_Underground_descriptor(), name, value);
}
// ===================================================================

class TimeOfDayEnum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.TimeOfDayEnum) */ {
 public:
  TimeOfDayEnum();
  virtual ~TimeOfDayEnum();

  TimeOfDayEnum(const TimeOfDayEnum& from);

  inline TimeOfDayEnum& operator=(const TimeOfDayEnum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeOfDayEnum(TimeOfDayEnum&& from) noexcept
    : TimeOfDayEnum() {
    *this = ::std::move(from);
  }

  inline TimeOfDayEnum& operator=(TimeOfDayEnum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeOfDayEnum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeOfDayEnum* internal_default_instance() {
    return reinterpret_cast<const TimeOfDayEnum*>(
               &_TimeOfDayEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TimeOfDayEnum* other);
  friend void swap(TimeOfDayEnum& a, TimeOfDayEnum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeOfDayEnum* New() const final {
    return CreateMaybeMessage<TimeOfDayEnum>(NULL);
  }

  TimeOfDayEnum* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TimeOfDayEnum>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TimeOfDayEnum& from);
  void MergeFrom(const TimeOfDayEnum& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeOfDayEnum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TimeOfDayEnum_TimeOfDay TimeOfDay;
  static const TimeOfDay NIGHT =
    TimeOfDayEnum_TimeOfDay_NIGHT;
  static const TimeOfDay DAY =
    TimeOfDayEnum_TimeOfDay_DAY;
  static const TimeOfDay UNKNOWN =
    TimeOfDayEnum_TimeOfDay_UNKNOWN;
  static inline bool TimeOfDay_IsValid(int value) {
    return TimeOfDayEnum_TimeOfDay_IsValid(value);
  }
  static const TimeOfDay TimeOfDay_MIN =
    TimeOfDayEnum_TimeOfDay_TimeOfDay_MIN;
  static const TimeOfDay TimeOfDay_MAX =
    TimeOfDayEnum_TimeOfDay_TimeOfDay_MAX;
  static const int TimeOfDay_ARRAYSIZE =
    TimeOfDayEnum_TimeOfDay_TimeOfDay_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TimeOfDay_descriptor() {
    return TimeOfDayEnum_TimeOfDay_descriptor();
  }
  static inline const ::std::string& TimeOfDay_Name(TimeOfDay value) {
    return TimeOfDayEnum_TimeOfDay_Name(value);
  }
  static inline bool TimeOfDay_Parse(const ::std::string& name,
      TimeOfDay* value) {
    return TimeOfDayEnum_TimeOfDay_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:commonroad.TimeOfDayEnum)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_location_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WeatherEnum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.WeatherEnum) */ {
 public:
  WeatherEnum();
  virtual ~WeatherEnum();

  WeatherEnum(const WeatherEnum& from);

  inline WeatherEnum& operator=(const WeatherEnum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WeatherEnum(WeatherEnum&& from) noexcept
    : WeatherEnum() {
    *this = ::std::move(from);
  }

  inline WeatherEnum& operator=(WeatherEnum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeatherEnum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WeatherEnum* internal_default_instance() {
    return reinterpret_cast<const WeatherEnum*>(
               &_WeatherEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(WeatherEnum* other);
  friend void swap(WeatherEnum& a, WeatherEnum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WeatherEnum* New() const final {
    return CreateMaybeMessage<WeatherEnum>(NULL);
  }

  WeatherEnum* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WeatherEnum>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WeatherEnum& from);
  void MergeFrom(const WeatherEnum& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WeatherEnum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WeatherEnum_Weather Weather;
  static const Weather SUNNY =
    WeatherEnum_Weather_SUNNY;
  static const Weather LIGHT_RAIN =
    WeatherEnum_Weather_LIGHT_RAIN;
  static const Weather HEAVY_AIN =
    WeatherEnum_Weather_HEAVY_AIN;
  static const Weather FOG =
    WeatherEnum_Weather_FOG;
  static const Weather SNOW =
    WeatherEnum_Weather_SNOW;
  static const Weather HAIL =
    WeatherEnum_Weather_HAIL;
  static const Weather UNKNOWN =
    WeatherEnum_Weather_UNKNOWN;
  static inline bool Weather_IsValid(int value) {
    return WeatherEnum_Weather_IsValid(value);
  }
  static const Weather Weather_MIN =
    WeatherEnum_Weather_Weather_MIN;
  static const Weather Weather_MAX =
    WeatherEnum_Weather_Weather_MAX;
  static const int Weather_ARRAYSIZE =
    WeatherEnum_Weather_Weather_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Weather_descriptor() {
    return WeatherEnum_Weather_descriptor();
  }
  static inline const ::std::string& Weather_Name(Weather value) {
    return WeatherEnum_Weather_Name(value);
  }
  static inline bool Weather_Parse(const ::std::string& name,
      Weather* value) {
    return WeatherEnum_Weather_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:commonroad.WeatherEnum)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_location_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UndergroundEnum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.UndergroundEnum) */ {
 public:
  UndergroundEnum();
  virtual ~UndergroundEnum();

  UndergroundEnum(const UndergroundEnum& from);

  inline UndergroundEnum& operator=(const UndergroundEnum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UndergroundEnum(UndergroundEnum&& from) noexcept
    : UndergroundEnum() {
    *this = ::std::move(from);
  }

  inline UndergroundEnum& operator=(UndergroundEnum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndergroundEnum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UndergroundEnum* internal_default_instance() {
    return reinterpret_cast<const UndergroundEnum*>(
               &_UndergroundEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UndergroundEnum* other);
  friend void swap(UndergroundEnum& a, UndergroundEnum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UndergroundEnum* New() const final {
    return CreateMaybeMessage<UndergroundEnum>(NULL);
  }

  UndergroundEnum* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UndergroundEnum>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UndergroundEnum& from);
  void MergeFrom(const UndergroundEnum& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndergroundEnum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UndergroundEnum_Underground Underground;
  static const Underground WET =
    UndergroundEnum_Underground_WET;
  static const Underground CLEAN =
    UndergroundEnum_Underground_CLEAN;
  static const Underground DIRTY =
    UndergroundEnum_Underground_DIRTY;
  static const Underground DAMAGED =
    UndergroundEnum_Underground_DAMAGED;
  static const Underground SNOW =
    UndergroundEnum_Underground_SNOW;
  static const Underground ICE =
    UndergroundEnum_Underground_ICE;
  static const Underground UNKNOWN =
    UndergroundEnum_Underground_UNKNOWN;
  static inline bool Underground_IsValid(int value) {
    return UndergroundEnum_Underground_IsValid(value);
  }
  static const Underground Underground_MIN =
    UndergroundEnum_Underground_Underground_MIN;
  static const Underground Underground_MAX =
    UndergroundEnum_Underground_Underground_MAX;
  static const int Underground_ARRAYSIZE =
    UndergroundEnum_Underground_Underground_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Underground_descriptor() {
    return UndergroundEnum_Underground_descriptor();
  }
  static inline const ::std::string& Underground_Name(Underground value) {
    return UndergroundEnum_Underground_Name(value);
  }
  static inline bool Underground_Parse(const ::std::string& name,
      Underground* value) {
    return UndergroundEnum_Underground_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:commonroad.UndergroundEnum)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_location_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GeoTransformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.GeoTransformation) */ {
 public:
  GeoTransformation();
  virtual ~GeoTransformation();

  GeoTransformation(const GeoTransformation& from);

  inline GeoTransformation& operator=(const GeoTransformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeoTransformation(GeoTransformation&& from) noexcept
    : GeoTransformation() {
    *this = ::std::move(from);
  }

  inline GeoTransformation& operator=(GeoTransformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoTransformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoTransformation* internal_default_instance() {
    return reinterpret_cast<const GeoTransformation*>(
               &_GeoTransformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GeoTransformation* other);
  friend void swap(GeoTransformation& a, GeoTransformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeoTransformation* New() const final {
    return CreateMaybeMessage<GeoTransformation>(NULL);
  }

  GeoTransformation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GeoTransformation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GeoTransformation& from);
  void MergeFrom(const GeoTransformation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoTransformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string geo_reference = 1;
  bool has_geo_reference() const;
  void clear_geo_reference();
  static const int kGeoReferenceFieldNumber = 1;
  const ::std::string& geo_reference() const;
  void set_geo_reference(const ::std::string& value);
  #if LANG_CXX11
  void set_geo_reference(::std::string&& value);
  #endif
  void set_geo_reference(const char* value);
  void set_geo_reference(const char* value, size_t size);
  ::std::string* mutable_geo_reference();
  ::std::string* release_geo_reference();
  void set_allocated_geo_reference(::std::string* geo_reference);

  // optional double x_translation = 2;
  bool has_x_translation() const;
  void clear_x_translation();
  static const int kXTranslationFieldNumber = 2;
  double x_translation() const;
  void set_x_translation(double value);

  // optional double y_translation = 3;
  bool has_y_translation() const;
  void clear_y_translation();
  static const int kYTranslationFieldNumber = 3;
  double y_translation() const;
  void set_y_translation(double value);

  // optional double z_rotation = 4;
  bool has_z_rotation() const;
  void clear_z_rotation();
  static const int kZRotationFieldNumber = 4;
  double z_rotation() const;
  void set_z_rotation(double value);

  // optional double scaling = 5;
  bool has_scaling() const;
  void clear_scaling();
  static const int kScalingFieldNumber = 5;
  double scaling() const;
  void set_scaling(double value);

  // @@protoc_insertion_point(class_scope:commonroad.GeoTransformation)
 private:
  void set_has_geo_reference();
  void clear_has_geo_reference();
  void set_has_x_translation();
  void clear_has_x_translation();
  void set_has_y_translation();
  void clear_has_y_translation();
  void set_has_z_rotation();
  void clear_has_z_rotation();
  void set_has_scaling();
  void clear_has_scaling();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr geo_reference_;
  double x_translation_;
  double y_translation_;
  double z_rotation_;
  double scaling_;
  friend struct ::protobuf_location_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Environment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.Environment) */ {
 public:
  Environment();
  virtual ~Environment();

  Environment(const Environment& from);

  inline Environment& operator=(const Environment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Environment(Environment&& from) noexcept
    : Environment() {
    *this = ::std::move(from);
  }

  inline Environment& operator=(Environment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Environment* internal_default_instance() {
    return reinterpret_cast<const Environment*>(
               &_Environment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Environment* other);
  friend void swap(Environment& a, Environment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Environment* New() const final {
    return CreateMaybeMessage<Environment>(NULL);
  }

  Environment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Environment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Environment& from);
  void MergeFrom(const Environment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Environment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .commonroad.TimeStamp time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  private:
  const ::commonroad::TimeStamp& _internal_time() const;
  public:
  const ::commonroad::TimeStamp& time() const;
  ::commonroad::TimeStamp* release_time();
  ::commonroad::TimeStamp* mutable_time();
  void set_allocated_time(::commonroad::TimeStamp* time);

  // optional .commonroad.TimeOfDayEnum.TimeOfDay time_of_day = 2;
  bool has_time_of_day() const;
  void clear_time_of_day();
  static const int kTimeOfDayFieldNumber = 2;
  ::commonroad::TimeOfDayEnum_TimeOfDay time_of_day() const;
  void set_time_of_day(::commonroad::TimeOfDayEnum_TimeOfDay value);

  // optional .commonroad.WeatherEnum.Weather weather = 3;
  bool has_weather() const;
  void clear_weather();
  static const int kWeatherFieldNumber = 3;
  ::commonroad::WeatherEnum_Weather weather() const;
  void set_weather(::commonroad::WeatherEnum_Weather value);

  // optional .commonroad.UndergroundEnum.Underground underground = 4;
  bool has_underground() const;
  void clear_underground();
  static const int kUndergroundFieldNumber = 4;
  ::commonroad::UndergroundEnum_Underground underground() const;
  void set_underground(::commonroad::UndergroundEnum_Underground value);

  // @@protoc_insertion_point(class_scope:commonroad.Environment)
 private:
  void set_has_time();
  void clear_has_time();
  void set_has_time_of_day();
  void clear_has_time_of_day();
  void set_has_weather();
  void clear_has_weather();
  void set_has_underground();
  void clear_has_underground();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::commonroad::TimeStamp* time_;
  int time_of_day_;
  int weather_;
  int underground_;
  friend struct ::protobuf_location_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Location* other);
  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Location* New() const final {
    return CreateMaybeMessage<Location>(NULL);
  }

  Location* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .commonroad.GeoTransformation geo_transformation = 4;
  bool has_geo_transformation() const;
  void clear_geo_transformation();
  static const int kGeoTransformationFieldNumber = 4;
  private:
  const ::commonroad::GeoTransformation& _internal_geo_transformation() const;
  public:
  const ::commonroad::GeoTransformation& geo_transformation() const;
  ::commonroad::GeoTransformation* release_geo_transformation();
  ::commonroad::GeoTransformation* mutable_geo_transformation();
  void set_allocated_geo_transformation(::commonroad::GeoTransformation* geo_transformation);

  // optional .commonroad.Environment environment = 5;
  bool has_environment() const;
  void clear_environment();
  static const int kEnvironmentFieldNumber = 5;
  private:
  const ::commonroad::Environment& _internal_environment() const;
  public:
  const ::commonroad::Environment& environment() const;
  ::commonroad::Environment* release_environment();
  ::commonroad::Environment* mutable_environment();
  void set_allocated_environment(::commonroad::Environment* environment);

  // required double gps_latitude = 2;
  bool has_gps_latitude() const;
  void clear_gps_latitude();
  static const int kGpsLatitudeFieldNumber = 2;
  double gps_latitude() const;
  void set_gps_latitude(double value);

  // required double gps_longitude = 3;
  bool has_gps_longitude() const;
  void clear_gps_longitude();
  static const int kGpsLongitudeFieldNumber = 3;
  double gps_longitude() const;
  void set_gps_longitude(double value);

  // required int32 geo_name_id = 1;
  bool has_geo_name_id() const;
  void clear_geo_name_id();
  static const int kGeoNameIdFieldNumber = 1;
  ::google::protobuf::int32 geo_name_id() const;
  void set_geo_name_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:commonroad.Location)
 private:
  void set_has_geo_name_id();
  void clear_has_geo_name_id();
  void set_has_gps_latitude();
  void clear_has_gps_latitude();
  void set_has_gps_longitude();
  void clear_has_gps_longitude();
  void set_has_geo_transformation();
  void clear_has_geo_transformation();
  void set_has_environment();
  void clear_has_environment();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::commonroad::GeoTransformation* geo_transformation_;
  ::commonroad::Environment* environment_;
  double gps_latitude_;
  double gps_longitude_;
  ::google::protobuf::int32 geo_name_id_;
  friend struct ::protobuf_location_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TimeOfDayEnum

// -------------------------------------------------------------------

// WeatherEnum

// -------------------------------------------------------------------

// UndergroundEnum

// -------------------------------------------------------------------

// GeoTransformation

// optional string geo_reference = 1;
inline bool GeoTransformation::has_geo_reference() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoTransformation::set_has_geo_reference() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoTransformation::clear_has_geo_reference() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoTransformation::clear_geo_reference() {
  geo_reference_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_geo_reference();
}
inline const ::std::string& GeoTransformation::geo_reference() const {
  // @@protoc_insertion_point(field_get:commonroad.GeoTransformation.geo_reference)
  return geo_reference_.GetNoArena();
}
inline void GeoTransformation::set_geo_reference(const ::std::string& value) {
  set_has_geo_reference();
  geo_reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:commonroad.GeoTransformation.geo_reference)
}
#if LANG_CXX11
inline void GeoTransformation::set_geo_reference(::std::string&& value) {
  set_has_geo_reference();
  geo_reference_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:commonroad.GeoTransformation.geo_reference)
}
#endif
inline void GeoTransformation::set_geo_reference(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_geo_reference();
  geo_reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:commonroad.GeoTransformation.geo_reference)
}
inline void GeoTransformation::set_geo_reference(const char* value, size_t size) {
  set_has_geo_reference();
  geo_reference_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:commonroad.GeoTransformation.geo_reference)
}
inline ::std::string* GeoTransformation::mutable_geo_reference() {
  set_has_geo_reference();
  // @@protoc_insertion_point(field_mutable:commonroad.GeoTransformation.geo_reference)
  return geo_reference_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GeoTransformation::release_geo_reference() {
  // @@protoc_insertion_point(field_release:commonroad.GeoTransformation.geo_reference)
  if (!has_geo_reference()) {
    return NULL;
  }
  clear_has_geo_reference();
  return geo_reference_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GeoTransformation::set_allocated_geo_reference(::std::string* geo_reference) {
  if (geo_reference != NULL) {
    set_has_geo_reference();
  } else {
    clear_has_geo_reference();
  }
  geo_reference_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), geo_reference);
  // @@protoc_insertion_point(field_set_allocated:commonroad.GeoTransformation.geo_reference)
}

// optional double x_translation = 2;
inline bool GeoTransformation::has_x_translation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoTransformation::set_has_x_translation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoTransformation::clear_has_x_translation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoTransformation::clear_x_translation() {
  x_translation_ = 0;
  clear_has_x_translation();
}
inline double GeoTransformation::x_translation() const {
  // @@protoc_insertion_point(field_get:commonroad.GeoTransformation.x_translation)
  return x_translation_;
}
inline void GeoTransformation::set_x_translation(double value) {
  set_has_x_translation();
  x_translation_ = value;
  // @@protoc_insertion_point(field_set:commonroad.GeoTransformation.x_translation)
}

// optional double y_translation = 3;
inline bool GeoTransformation::has_y_translation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeoTransformation::set_has_y_translation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeoTransformation::clear_has_y_translation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeoTransformation::clear_y_translation() {
  y_translation_ = 0;
  clear_has_y_translation();
}
inline double GeoTransformation::y_translation() const {
  // @@protoc_insertion_point(field_get:commonroad.GeoTransformation.y_translation)
  return y_translation_;
}
inline void GeoTransformation::set_y_translation(double value) {
  set_has_y_translation();
  y_translation_ = value;
  // @@protoc_insertion_point(field_set:commonroad.GeoTransformation.y_translation)
}

// optional double z_rotation = 4;
inline bool GeoTransformation::has_z_rotation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeoTransformation::set_has_z_rotation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeoTransformation::clear_has_z_rotation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeoTransformation::clear_z_rotation() {
  z_rotation_ = 0;
  clear_has_z_rotation();
}
inline double GeoTransformation::z_rotation() const {
  // @@protoc_insertion_point(field_get:commonroad.GeoTransformation.z_rotation)
  return z_rotation_;
}
inline void GeoTransformation::set_z_rotation(double value) {
  set_has_z_rotation();
  z_rotation_ = value;
  // @@protoc_insertion_point(field_set:commonroad.GeoTransformation.z_rotation)
}

// optional double scaling = 5;
inline bool GeoTransformation::has_scaling() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GeoTransformation::set_has_scaling() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GeoTransformation::clear_has_scaling() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GeoTransformation::clear_scaling() {
  scaling_ = 0;
  clear_has_scaling();
}
inline double GeoTransformation::scaling() const {
  // @@protoc_insertion_point(field_get:commonroad.GeoTransformation.scaling)
  return scaling_;
}
inline void GeoTransformation::set_scaling(double value) {
  set_has_scaling();
  scaling_ = value;
  // @@protoc_insertion_point(field_set:commonroad.GeoTransformation.scaling)
}

// -------------------------------------------------------------------

// Environment

// optional .commonroad.TimeStamp time = 1;
inline bool Environment::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Environment::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Environment::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::commonroad::TimeStamp& Environment::_internal_time() const {
  return *time_;
}
inline const ::commonroad::TimeStamp& Environment::time() const {
  const ::commonroad::TimeStamp* p = time_;
  // @@protoc_insertion_point(field_get:commonroad.Environment.time)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::TimeStamp*>(
      &::commonroad::_TimeStamp_default_instance_);
}
inline ::commonroad::TimeStamp* Environment::release_time() {
  // @@protoc_insertion_point(field_release:commonroad.Environment.time)
  clear_has_time();
  ::commonroad::TimeStamp* temp = time_;
  time_ = NULL;
  return temp;
}
inline ::commonroad::TimeStamp* Environment::mutable_time() {
  set_has_time();
  if (time_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::TimeStamp>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Environment.time)
  return time_;
}
inline void Environment::set_allocated_time(::commonroad::TimeStamp* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_);
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    set_has_time();
  } else {
    clear_has_time();
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:commonroad.Environment.time)
}

// optional .commonroad.TimeOfDayEnum.TimeOfDay time_of_day = 2;
inline bool Environment::has_time_of_day() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Environment::set_has_time_of_day() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Environment::clear_has_time_of_day() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Environment::clear_time_of_day() {
  time_of_day_ = 0;
  clear_has_time_of_day();
}
inline ::commonroad::TimeOfDayEnum_TimeOfDay Environment::time_of_day() const {
  // @@protoc_insertion_point(field_get:commonroad.Environment.time_of_day)
  return static_cast< ::commonroad::TimeOfDayEnum_TimeOfDay >(time_of_day_);
}
inline void Environment::set_time_of_day(::commonroad::TimeOfDayEnum_TimeOfDay value) {
  assert(::commonroad::TimeOfDayEnum_TimeOfDay_IsValid(value));
  set_has_time_of_day();
  time_of_day_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Environment.time_of_day)
}

// optional .commonroad.WeatherEnum.Weather weather = 3;
inline bool Environment::has_weather() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Environment::set_has_weather() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Environment::clear_has_weather() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Environment::clear_weather() {
  weather_ = 0;
  clear_has_weather();
}
inline ::commonroad::WeatherEnum_Weather Environment::weather() const {
  // @@protoc_insertion_point(field_get:commonroad.Environment.weather)
  return static_cast< ::commonroad::WeatherEnum_Weather >(weather_);
}
inline void Environment::set_weather(::commonroad::WeatherEnum_Weather value) {
  assert(::commonroad::WeatherEnum_Weather_IsValid(value));
  set_has_weather();
  weather_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Environment.weather)
}

// optional .commonroad.UndergroundEnum.Underground underground = 4;
inline bool Environment::has_underground() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Environment::set_has_underground() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Environment::clear_has_underground() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Environment::clear_underground() {
  underground_ = 0;
  clear_has_underground();
}
inline ::commonroad::UndergroundEnum_Underground Environment::underground() const {
  // @@protoc_insertion_point(field_get:commonroad.Environment.underground)
  return static_cast< ::commonroad::UndergroundEnum_Underground >(underground_);
}
inline void Environment::set_underground(::commonroad::UndergroundEnum_Underground value) {
  assert(::commonroad::UndergroundEnum_Underground_IsValid(value));
  set_has_underground();
  underground_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Environment.underground)
}

// -------------------------------------------------------------------

// Location

// required int32 geo_name_id = 1;
inline bool Location::has_geo_name_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Location::set_has_geo_name_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Location::clear_has_geo_name_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Location::clear_geo_name_id() {
  geo_name_id_ = 0;
  clear_has_geo_name_id();
}
inline ::google::protobuf::int32 Location::geo_name_id() const {
  // @@protoc_insertion_point(field_get:commonroad.Location.geo_name_id)
  return geo_name_id_;
}
inline void Location::set_geo_name_id(::google::protobuf::int32 value) {
  set_has_geo_name_id();
  geo_name_id_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Location.geo_name_id)
}

// required double gps_latitude = 2;
inline bool Location::has_gps_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Location::set_has_gps_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Location::clear_has_gps_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Location::clear_gps_latitude() {
  gps_latitude_ = 0;
  clear_has_gps_latitude();
}
inline double Location::gps_latitude() const {
  // @@protoc_insertion_point(field_get:commonroad.Location.gps_latitude)
  return gps_latitude_;
}
inline void Location::set_gps_latitude(double value) {
  set_has_gps_latitude();
  gps_latitude_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Location.gps_latitude)
}

// required double gps_longitude = 3;
inline bool Location::has_gps_longitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Location::set_has_gps_longitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Location::clear_has_gps_longitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Location::clear_gps_longitude() {
  gps_longitude_ = 0;
  clear_has_gps_longitude();
}
inline double Location::gps_longitude() const {
  // @@protoc_insertion_point(field_get:commonroad.Location.gps_longitude)
  return gps_longitude_;
}
inline void Location::set_gps_longitude(double value) {
  set_has_gps_longitude();
  gps_longitude_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Location.gps_longitude)
}

// optional .commonroad.GeoTransformation geo_transformation = 4;
inline bool Location::has_geo_transformation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_geo_transformation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_geo_transformation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_geo_transformation() {
  if (geo_transformation_ != NULL) geo_transformation_->Clear();
  clear_has_geo_transformation();
}
inline const ::commonroad::GeoTransformation& Location::_internal_geo_transformation() const {
  return *geo_transformation_;
}
inline const ::commonroad::GeoTransformation& Location::geo_transformation() const {
  const ::commonroad::GeoTransformation* p = geo_transformation_;
  // @@protoc_insertion_point(field_get:commonroad.Location.geo_transformation)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::GeoTransformation*>(
      &::commonroad::_GeoTransformation_default_instance_);
}
inline ::commonroad::GeoTransformation* Location::release_geo_transformation() {
  // @@protoc_insertion_point(field_release:commonroad.Location.geo_transformation)
  clear_has_geo_transformation();
  ::commonroad::GeoTransformation* temp = geo_transformation_;
  geo_transformation_ = NULL;
  return temp;
}
inline ::commonroad::GeoTransformation* Location::mutable_geo_transformation() {
  set_has_geo_transformation();
  if (geo_transformation_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::GeoTransformation>(GetArenaNoVirtual());
    geo_transformation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Location.geo_transformation)
  return geo_transformation_;
}
inline void Location::set_allocated_geo_transformation(::commonroad::GeoTransformation* geo_transformation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geo_transformation_;
  }
  if (geo_transformation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geo_transformation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geo_transformation, submessage_arena);
    }
    set_has_geo_transformation();
  } else {
    clear_has_geo_transformation();
  }
  geo_transformation_ = geo_transformation;
  // @@protoc_insertion_point(field_set_allocated:commonroad.Location.geo_transformation)
}

// optional .commonroad.Environment environment = 5;
inline bool Location::has_environment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_environment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_environment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_environment() {
  if (environment_ != NULL) environment_->Clear();
  clear_has_environment();
}
inline const ::commonroad::Environment& Location::_internal_environment() const {
  return *environment_;
}
inline const ::commonroad::Environment& Location::environment() const {
  const ::commonroad::Environment* p = environment_;
  // @@protoc_insertion_point(field_get:commonroad.Location.environment)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::Environment*>(
      &::commonroad::_Environment_default_instance_);
}
inline ::commonroad::Environment* Location::release_environment() {
  // @@protoc_insertion_point(field_release:commonroad.Location.environment)
  clear_has_environment();
  ::commonroad::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline ::commonroad::Environment* Location::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::Environment>(GetArenaNoVirtual());
    environment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Location.environment)
  return environment_;
}
inline void Location::set_allocated_environment(::commonroad::Environment* environment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete environment_;
  }
  if (environment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      environment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, environment, submessage_arena);
    }
    set_has_environment();
  } else {
    clear_has_environment();
  }
  environment_ = environment;
  // @@protoc_insertion_point(field_set_allocated:commonroad.Location.environment)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commonroad

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::commonroad::TimeOfDayEnum_TimeOfDay> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonroad::TimeOfDayEnum_TimeOfDay>() {
  return ::commonroad::TimeOfDayEnum_TimeOfDay_descriptor();
}
template <> struct is_proto_enum< ::commonroad::WeatherEnum_Weather> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonroad::WeatherEnum_Weather>() {
  return ::commonroad::WeatherEnum_Weather_descriptor();
}
template <> struct is_proto_enum< ::commonroad::UndergroundEnum_Underground> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonroad::UndergroundEnum_Underground>() {
  return ::commonroad::UndergroundEnum_Underground_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_location_2eproto
