// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: obstacle.proto

#ifndef PROTOBUF_INCLUDED_obstacle_2eproto
#define PROTOBUF_INCLUDED_obstacle_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "util.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_obstacle_2eproto 

namespace protobuf_obstacle_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_obstacle_2eproto
namespace commonroad {
class ObstacleTypeEnum;
class ObstacleTypeEnumDefaultTypeInternal;
extern ObstacleTypeEnumDefaultTypeInternal _ObstacleTypeEnum_default_instance_;
class Occupancy;
class OccupancyDefaultTypeInternal;
extern OccupancyDefaultTypeInternal _Occupancy_default_instance_;
class OccupancySet;
class OccupancySetDefaultTypeInternal;
extern OccupancySetDefaultTypeInternal _OccupancySet_default_instance_;
class SetBasedPrediction;
class SetBasedPredictionDefaultTypeInternal;
extern SetBasedPredictionDefaultTypeInternal _SetBasedPrediction_default_instance_;
class SignalState;
class SignalStateDefaultTypeInternal;
extern SignalStateDefaultTypeInternal _SignalState_default_instance_;
class State;
class StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
class TrajectoryPrediction;
class TrajectoryPredictionDefaultTypeInternal;
extern TrajectoryPredictionDefaultTypeInternal _TrajectoryPrediction_default_instance_;
}  // namespace commonroad
namespace google {
namespace protobuf {
template<> ::commonroad::ObstacleTypeEnum* Arena::CreateMaybeMessage<::commonroad::ObstacleTypeEnum>(Arena*);
template<> ::commonroad::Occupancy* Arena::CreateMaybeMessage<::commonroad::Occupancy>(Arena*);
template<> ::commonroad::OccupancySet* Arena::CreateMaybeMessage<::commonroad::OccupancySet>(Arena*);
template<> ::commonroad::SetBasedPrediction* Arena::CreateMaybeMessage<::commonroad::SetBasedPrediction>(Arena*);
template<> ::commonroad::SignalState* Arena::CreateMaybeMessage<::commonroad::SignalState>(Arena*);
template<> ::commonroad::State* Arena::CreateMaybeMessage<::commonroad::State>(Arena*);
template<> ::commonroad::Trajectory* Arena::CreateMaybeMessage<::commonroad::Trajectory>(Arena*);
template<> ::commonroad::TrajectoryPrediction* Arena::CreateMaybeMessage<::commonroad::TrajectoryPrediction>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace commonroad {

enum ObstacleTypeEnum_ObstacleType {
  ObstacleTypeEnum_ObstacleType_UNKNOWN = 0,
  ObstacleTypeEnum_ObstacleType_CAR = 1,
  ObstacleTypeEnum_ObstacleType_TRUCK = 2,
  ObstacleTypeEnum_ObstacleType_BUS = 3,
  ObstacleTypeEnum_ObstacleType_BICYCLE = 4,
  ObstacleTypeEnum_ObstacleType_PEDESTRIAN = 5,
  ObstacleTypeEnum_ObstacleType_PRIORITY_VEHICLE = 6,
  ObstacleTypeEnum_ObstacleType_PARKED_VEHICLE = 7,
  ObstacleTypeEnum_ObstacleType_CONSTRUCTION_ZONE = 8,
  ObstacleTypeEnum_ObstacleType_TRAIN = 9,
  ObstacleTypeEnum_ObstacleType_ROAD_BOUNDARY = 10,
  ObstacleTypeEnum_ObstacleType_MOTORCYCLE = 11,
  ObstacleTypeEnum_ObstacleType_TAXI = 12,
  ObstacleTypeEnum_ObstacleType_BUILDING = 13,
  ObstacleTypeEnum_ObstacleType_PILLAR = 14,
  ObstacleTypeEnum_ObstacleType_MEDIAN_STRIP = 15
};
bool ObstacleTypeEnum_ObstacleType_IsValid(int value);
const ObstacleTypeEnum_ObstacleType ObstacleTypeEnum_ObstacleType_ObstacleType_MIN = ObstacleTypeEnum_ObstacleType_UNKNOWN;
const ObstacleTypeEnum_ObstacleType ObstacleTypeEnum_ObstacleType_ObstacleType_MAX = ObstacleTypeEnum_ObstacleType_MEDIAN_STRIP;
const int ObstacleTypeEnum_ObstacleType_ObstacleType_ARRAYSIZE = ObstacleTypeEnum_ObstacleType_ObstacleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObstacleTypeEnum_ObstacleType_descriptor();
inline const ::std::string& ObstacleTypeEnum_ObstacleType_Name(ObstacleTypeEnum_ObstacleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObstacleTypeEnum_ObstacleType_descriptor(), value);
}
inline bool ObstacleTypeEnum_ObstacleType_Parse(
    const ::std::string& name, ObstacleTypeEnum_ObstacleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstacleTypeEnum_ObstacleType>(
    ObstacleTypeEnum_ObstacleType_descriptor(), name, value);
}
// ===================================================================

class ObstacleTypeEnum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.ObstacleTypeEnum) */ {
 public:
  ObstacleTypeEnum();
  virtual ~ObstacleTypeEnum();

  ObstacleTypeEnum(const ObstacleTypeEnum& from);

  inline ObstacleTypeEnum& operator=(const ObstacleTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleTypeEnum(ObstacleTypeEnum&& from) noexcept
    : ObstacleTypeEnum() {
    *this = ::std::move(from);
  }

  inline ObstacleTypeEnum& operator=(ObstacleTypeEnum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleTypeEnum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleTypeEnum* internal_default_instance() {
    return reinterpret_cast<const ObstacleTypeEnum*>(
               &_ObstacleTypeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ObstacleTypeEnum* other);
  friend void swap(ObstacleTypeEnum& a, ObstacleTypeEnum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleTypeEnum* New() const final {
    return CreateMaybeMessage<ObstacleTypeEnum>(NULL);
  }

  ObstacleTypeEnum* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObstacleTypeEnum>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObstacleTypeEnum& from);
  void MergeFrom(const ObstacleTypeEnum& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleTypeEnum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObstacleTypeEnum_ObstacleType ObstacleType;
  static const ObstacleType UNKNOWN =
    ObstacleTypeEnum_ObstacleType_UNKNOWN;
  static const ObstacleType CAR =
    ObstacleTypeEnum_ObstacleType_CAR;
  static const ObstacleType TRUCK =
    ObstacleTypeEnum_ObstacleType_TRUCK;
  static const ObstacleType BUS =
    ObstacleTypeEnum_ObstacleType_BUS;
  static const ObstacleType BICYCLE =
    ObstacleTypeEnum_ObstacleType_BICYCLE;
  static const ObstacleType PEDESTRIAN =
    ObstacleTypeEnum_ObstacleType_PEDESTRIAN;
  static const ObstacleType PRIORITY_VEHICLE =
    ObstacleTypeEnum_ObstacleType_PRIORITY_VEHICLE;
  static const ObstacleType PARKED_VEHICLE =
    ObstacleTypeEnum_ObstacleType_PARKED_VEHICLE;
  static const ObstacleType CONSTRUCTION_ZONE =
    ObstacleTypeEnum_ObstacleType_CONSTRUCTION_ZONE;
  static const ObstacleType TRAIN =
    ObstacleTypeEnum_ObstacleType_TRAIN;
  static const ObstacleType ROAD_BOUNDARY =
    ObstacleTypeEnum_ObstacleType_ROAD_BOUNDARY;
  static const ObstacleType MOTORCYCLE =
    ObstacleTypeEnum_ObstacleType_MOTORCYCLE;
  static const ObstacleType TAXI =
    ObstacleTypeEnum_ObstacleType_TAXI;
  static const ObstacleType BUILDING =
    ObstacleTypeEnum_ObstacleType_BUILDING;
  static const ObstacleType PILLAR =
    ObstacleTypeEnum_ObstacleType_PILLAR;
  static const ObstacleType MEDIAN_STRIP =
    ObstacleTypeEnum_ObstacleType_MEDIAN_STRIP;
  static inline bool ObstacleType_IsValid(int value) {
    return ObstacleTypeEnum_ObstacleType_IsValid(value);
  }
  static const ObstacleType ObstacleType_MIN =
    ObstacleTypeEnum_ObstacleType_ObstacleType_MIN;
  static const ObstacleType ObstacleType_MAX =
    ObstacleTypeEnum_ObstacleType_ObstacleType_MAX;
  static const int ObstacleType_ARRAYSIZE =
    ObstacleTypeEnum_ObstacleType_ObstacleType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObstacleType_descriptor() {
    return ObstacleTypeEnum_ObstacleType_descriptor();
  }
  static inline const ::std::string& ObstacleType_Name(ObstacleType value) {
    return ObstacleTypeEnum_ObstacleType_Name(value);
  }
  static inline bool ObstacleType_Parse(const ::std::string& name,
      ObstacleType* value) {
    return ObstacleTypeEnum_ObstacleType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:commonroad.ObstacleTypeEnum)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_obstacle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.State) */ {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(State&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  enum PositionCase {
    kPoint = 1,
    kShape = 2,
    POSITION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(State* other);
  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State* New() const final {
    return CreateMaybeMessage<State>(NULL);
  }

  State* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<State>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .commonroad.FloatExactOrInterval orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_orientation() const;
  public:
  const ::commonroad::FloatExactOrInterval& orientation() const;
  ::commonroad::FloatExactOrInterval* release_orientation();
  ::commonroad::FloatExactOrInterval* mutable_orientation();
  void set_allocated_orientation(::commonroad::FloatExactOrInterval* orientation);

  // optional .commonroad.FloatExactOrInterval velocity = 4;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_velocity() const;
  public:
  const ::commonroad::FloatExactOrInterval& velocity() const;
  ::commonroad::FloatExactOrInterval* release_velocity();
  ::commonroad::FloatExactOrInterval* mutable_velocity();
  void set_allocated_velocity(::commonroad::FloatExactOrInterval* velocity);

  // optional .commonroad.FloatExactOrInterval steering_angle = 5;
  bool has_steering_angle() const;
  void clear_steering_angle();
  static const int kSteeringAngleFieldNumber = 5;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_steering_angle() const;
  public:
  const ::commonroad::FloatExactOrInterval& steering_angle() const;
  ::commonroad::FloatExactOrInterval* release_steering_angle();
  ::commonroad::FloatExactOrInterval* mutable_steering_angle();
  void set_allocated_steering_angle(::commonroad::FloatExactOrInterval* steering_angle);

  // optional .commonroad.FloatExactOrInterval steering_angle_speed = 6;
  bool has_steering_angle_speed() const;
  void clear_steering_angle_speed();
  static const int kSteeringAngleSpeedFieldNumber = 6;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_steering_angle_speed() const;
  public:
  const ::commonroad::FloatExactOrInterval& steering_angle_speed() const;
  ::commonroad::FloatExactOrInterval* release_steering_angle_speed();
  ::commonroad::FloatExactOrInterval* mutable_steering_angle_speed();
  void set_allocated_steering_angle_speed(::commonroad::FloatExactOrInterval* steering_angle_speed);

  // optional .commonroad.FloatExactOrInterval yaw_rate = 7;
  bool has_yaw_rate() const;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 7;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_yaw_rate() const;
  public:
  const ::commonroad::FloatExactOrInterval& yaw_rate() const;
  ::commonroad::FloatExactOrInterval* release_yaw_rate();
  ::commonroad::FloatExactOrInterval* mutable_yaw_rate();
  void set_allocated_yaw_rate(::commonroad::FloatExactOrInterval* yaw_rate);

  // optional .commonroad.FloatExactOrInterval slip_angle = 8;
  bool has_slip_angle() const;
  void clear_slip_angle();
  static const int kSlipAngleFieldNumber = 8;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_slip_angle() const;
  public:
  const ::commonroad::FloatExactOrInterval& slip_angle() const;
  ::commonroad::FloatExactOrInterval* release_slip_angle();
  ::commonroad::FloatExactOrInterval* mutable_slip_angle();
  void set_allocated_slip_angle(::commonroad::FloatExactOrInterval* slip_angle);

  // optional .commonroad.FloatExactOrInterval roll_angle = 9;
  bool has_roll_angle() const;
  void clear_roll_angle();
  static const int kRollAngleFieldNumber = 9;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_roll_angle() const;
  public:
  const ::commonroad::FloatExactOrInterval& roll_angle() const;
  ::commonroad::FloatExactOrInterval* release_roll_angle();
  ::commonroad::FloatExactOrInterval* mutable_roll_angle();
  void set_allocated_roll_angle(::commonroad::FloatExactOrInterval* roll_angle);

  // optional .commonroad.FloatExactOrInterval roll_rate = 10;
  bool has_roll_rate() const;
  void clear_roll_rate();
  static const int kRollRateFieldNumber = 10;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_roll_rate() const;
  public:
  const ::commonroad::FloatExactOrInterval& roll_rate() const;
  ::commonroad::FloatExactOrInterval* release_roll_rate();
  ::commonroad::FloatExactOrInterval* mutable_roll_rate();
  void set_allocated_roll_rate(::commonroad::FloatExactOrInterval* roll_rate);

  // optional .commonroad.FloatExactOrInterval pitch_angle = 11;
  bool has_pitch_angle() const;
  void clear_pitch_angle();
  static const int kPitchAngleFieldNumber = 11;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_pitch_angle() const;
  public:
  const ::commonroad::FloatExactOrInterval& pitch_angle() const;
  ::commonroad::FloatExactOrInterval* release_pitch_angle();
  ::commonroad::FloatExactOrInterval* mutable_pitch_angle();
  void set_allocated_pitch_angle(::commonroad::FloatExactOrInterval* pitch_angle);

  // optional .commonroad.FloatExactOrInterval pitch_rate = 12;
  bool has_pitch_rate() const;
  void clear_pitch_rate();
  static const int kPitchRateFieldNumber = 12;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_pitch_rate() const;
  public:
  const ::commonroad::FloatExactOrInterval& pitch_rate() const;
  ::commonroad::FloatExactOrInterval* release_pitch_rate();
  ::commonroad::FloatExactOrInterval* mutable_pitch_rate();
  void set_allocated_pitch_rate(::commonroad::FloatExactOrInterval* pitch_rate);

  // optional .commonroad.FloatExactOrInterval velocity_y = 13;
  bool has_velocity_y() const;
  void clear_velocity_y();
  static const int kVelocityYFieldNumber = 13;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_velocity_y() const;
  public:
  const ::commonroad::FloatExactOrInterval& velocity_y() const;
  ::commonroad::FloatExactOrInterval* release_velocity_y();
  ::commonroad::FloatExactOrInterval* mutable_velocity_y();
  void set_allocated_velocity_y(::commonroad::FloatExactOrInterval* velocity_y);

  // optional .commonroad.FloatExactOrInterval position_z = 14;
  bool has_position_z() const;
  void clear_position_z();
  static const int kPositionZFieldNumber = 14;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_position_z() const;
  public:
  const ::commonroad::FloatExactOrInterval& position_z() const;
  ::commonroad::FloatExactOrInterval* release_position_z();
  ::commonroad::FloatExactOrInterval* mutable_position_z();
  void set_allocated_position_z(::commonroad::FloatExactOrInterval* position_z);

  // optional .commonroad.FloatExactOrInterval velocity_z = 15;
  bool has_velocity_z() const;
  void clear_velocity_z();
  static const int kVelocityZFieldNumber = 15;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_velocity_z() const;
  public:
  const ::commonroad::FloatExactOrInterval& velocity_z() const;
  ::commonroad::FloatExactOrInterval* release_velocity_z();
  ::commonroad::FloatExactOrInterval* mutable_velocity_z();
  void set_allocated_velocity_z(::commonroad::FloatExactOrInterval* velocity_z);

  // optional .commonroad.FloatExactOrInterval roll_angle_front = 16;
  bool has_roll_angle_front() const;
  void clear_roll_angle_front();
  static const int kRollAngleFrontFieldNumber = 16;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_roll_angle_front() const;
  public:
  const ::commonroad::FloatExactOrInterval& roll_angle_front() const;
  ::commonroad::FloatExactOrInterval* release_roll_angle_front();
  ::commonroad::FloatExactOrInterval* mutable_roll_angle_front();
  void set_allocated_roll_angle_front(::commonroad::FloatExactOrInterval* roll_angle_front);

  // optional .commonroad.FloatExactOrInterval roll_rate_front = 17;
  bool has_roll_rate_front() const;
  void clear_roll_rate_front();
  static const int kRollRateFrontFieldNumber = 17;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_roll_rate_front() const;
  public:
  const ::commonroad::FloatExactOrInterval& roll_rate_front() const;
  ::commonroad::FloatExactOrInterval* release_roll_rate_front();
  ::commonroad::FloatExactOrInterval* mutable_roll_rate_front();
  void set_allocated_roll_rate_front(::commonroad::FloatExactOrInterval* roll_rate_front);

  // optional .commonroad.FloatExactOrInterval velocity_y_front = 18;
  bool has_velocity_y_front() const;
  void clear_velocity_y_front();
  static const int kVelocityYFrontFieldNumber = 18;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_velocity_y_front() const;
  public:
  const ::commonroad::FloatExactOrInterval& velocity_y_front() const;
  ::commonroad::FloatExactOrInterval* release_velocity_y_front();
  ::commonroad::FloatExactOrInterval* mutable_velocity_y_front();
  void set_allocated_velocity_y_front(::commonroad::FloatExactOrInterval* velocity_y_front);

  // optional .commonroad.FloatExactOrInterval position_z_front = 19;
  bool has_position_z_front() const;
  void clear_position_z_front();
  static const int kPositionZFrontFieldNumber = 19;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_position_z_front() const;
  public:
  const ::commonroad::FloatExactOrInterval& position_z_front() const;
  ::commonroad::FloatExactOrInterval* release_position_z_front();
  ::commonroad::FloatExactOrInterval* mutable_position_z_front();
  void set_allocated_position_z_front(::commonroad::FloatExactOrInterval* position_z_front);

  // optional .commonroad.FloatExactOrInterval velocity_z_front = 20;
  bool has_velocity_z_front() const;
  void clear_velocity_z_front();
  static const int kVelocityZFrontFieldNumber = 20;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_velocity_z_front() const;
  public:
  const ::commonroad::FloatExactOrInterval& velocity_z_front() const;
  ::commonroad::FloatExactOrInterval* release_velocity_z_front();
  ::commonroad::FloatExactOrInterval* mutable_velocity_z_front();
  void set_allocated_velocity_z_front(::commonroad::FloatExactOrInterval* velocity_z_front);

  // optional .commonroad.FloatExactOrInterval roll_angle_rear = 21;
  bool has_roll_angle_rear() const;
  void clear_roll_angle_rear();
  static const int kRollAngleRearFieldNumber = 21;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_roll_angle_rear() const;
  public:
  const ::commonroad::FloatExactOrInterval& roll_angle_rear() const;
  ::commonroad::FloatExactOrInterval* release_roll_angle_rear();
  ::commonroad::FloatExactOrInterval* mutable_roll_angle_rear();
  void set_allocated_roll_angle_rear(::commonroad::FloatExactOrInterval* roll_angle_rear);

  // optional .commonroad.FloatExactOrInterval roll_rate_rear = 22;
  bool has_roll_rate_rear() const;
  void clear_roll_rate_rear();
  static const int kRollRateRearFieldNumber = 22;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_roll_rate_rear() const;
  public:
  const ::commonroad::FloatExactOrInterval& roll_rate_rear() const;
  ::commonroad::FloatExactOrInterval* release_roll_rate_rear();
  ::commonroad::FloatExactOrInterval* mutable_roll_rate_rear();
  void set_allocated_roll_rate_rear(::commonroad::FloatExactOrInterval* roll_rate_rear);

  // optional .commonroad.FloatExactOrInterval velocity_y_rear = 23;
  bool has_velocity_y_rear() const;
  void clear_velocity_y_rear();
  static const int kVelocityYRearFieldNumber = 23;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_velocity_y_rear() const;
  public:
  const ::commonroad::FloatExactOrInterval& velocity_y_rear() const;
  ::commonroad::FloatExactOrInterval* release_velocity_y_rear();
  ::commonroad::FloatExactOrInterval* mutable_velocity_y_rear();
  void set_allocated_velocity_y_rear(::commonroad::FloatExactOrInterval* velocity_y_rear);

  // optional .commonroad.FloatExactOrInterval position_z_rear = 24;
  bool has_position_z_rear() const;
  void clear_position_z_rear();
  static const int kPositionZRearFieldNumber = 24;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_position_z_rear() const;
  public:
  const ::commonroad::FloatExactOrInterval& position_z_rear() const;
  ::commonroad::FloatExactOrInterval* release_position_z_rear();
  ::commonroad::FloatExactOrInterval* mutable_position_z_rear();
  void set_allocated_position_z_rear(::commonroad::FloatExactOrInterval* position_z_rear);

  // optional .commonroad.FloatExactOrInterval velocity_z_rear = 25;
  bool has_velocity_z_rear() const;
  void clear_velocity_z_rear();
  static const int kVelocityZRearFieldNumber = 25;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_velocity_z_rear() const;
  public:
  const ::commonroad::FloatExactOrInterval& velocity_z_rear() const;
  ::commonroad::FloatExactOrInterval* release_velocity_z_rear();
  ::commonroad::FloatExactOrInterval* mutable_velocity_z_rear();
  void set_allocated_velocity_z_rear(::commonroad::FloatExactOrInterval* velocity_z_rear);

  // optional .commonroad.FloatExactOrInterval left_front_wheel_angular_speed = 26;
  bool has_left_front_wheel_angular_speed() const;
  void clear_left_front_wheel_angular_speed();
  static const int kLeftFrontWheelAngularSpeedFieldNumber = 26;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_left_front_wheel_angular_speed() const;
  public:
  const ::commonroad::FloatExactOrInterval& left_front_wheel_angular_speed() const;
  ::commonroad::FloatExactOrInterval* release_left_front_wheel_angular_speed();
  ::commonroad::FloatExactOrInterval* mutable_left_front_wheel_angular_speed();
  void set_allocated_left_front_wheel_angular_speed(::commonroad::FloatExactOrInterval* left_front_wheel_angular_speed);

  // optional .commonroad.FloatExactOrInterval right_front_wheel_angular_speed = 27;
  bool has_right_front_wheel_angular_speed() const;
  void clear_right_front_wheel_angular_speed();
  static const int kRightFrontWheelAngularSpeedFieldNumber = 27;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_right_front_wheel_angular_speed() const;
  public:
  const ::commonroad::FloatExactOrInterval& right_front_wheel_angular_speed() const;
  ::commonroad::FloatExactOrInterval* release_right_front_wheel_angular_speed();
  ::commonroad::FloatExactOrInterval* mutable_right_front_wheel_angular_speed();
  void set_allocated_right_front_wheel_angular_speed(::commonroad::FloatExactOrInterval* right_front_wheel_angular_speed);

  // optional .commonroad.FloatExactOrInterval left_rear_wheel_angular_speed = 28;
  bool has_left_rear_wheel_angular_speed() const;
  void clear_left_rear_wheel_angular_speed();
  static const int kLeftRearWheelAngularSpeedFieldNumber = 28;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_left_rear_wheel_angular_speed() const;
  public:
  const ::commonroad::FloatExactOrInterval& left_rear_wheel_angular_speed() const;
  ::commonroad::FloatExactOrInterval* release_left_rear_wheel_angular_speed();
  ::commonroad::FloatExactOrInterval* mutable_left_rear_wheel_angular_speed();
  void set_allocated_left_rear_wheel_angular_speed(::commonroad::FloatExactOrInterval* left_rear_wheel_angular_speed);

  // optional .commonroad.FloatExactOrInterval right_rear_wheel_angular_speed = 29;
  bool has_right_rear_wheel_angular_speed() const;
  void clear_right_rear_wheel_angular_speed();
  static const int kRightRearWheelAngularSpeedFieldNumber = 29;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_right_rear_wheel_angular_speed() const;
  public:
  const ::commonroad::FloatExactOrInterval& right_rear_wheel_angular_speed() const;
  ::commonroad::FloatExactOrInterval* release_right_rear_wheel_angular_speed();
  ::commonroad::FloatExactOrInterval* mutable_right_rear_wheel_angular_speed();
  void set_allocated_right_rear_wheel_angular_speed(::commonroad::FloatExactOrInterval* right_rear_wheel_angular_speed);

  // optional .commonroad.FloatExactOrInterval delta_y_f = 30;
  bool has_delta_y_f() const;
  void clear_delta_y_f();
  static const int kDeltaYFFieldNumber = 30;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_delta_y_f() const;
  public:
  const ::commonroad::FloatExactOrInterval& delta_y_f() const;
  ::commonroad::FloatExactOrInterval* release_delta_y_f();
  ::commonroad::FloatExactOrInterval* mutable_delta_y_f();
  void set_allocated_delta_y_f(::commonroad::FloatExactOrInterval* delta_y_f);

  // optional .commonroad.FloatExactOrInterval delta_y_r = 31;
  bool has_delta_y_r() const;
  void clear_delta_y_r();
  static const int kDeltaYRFieldNumber = 31;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_delta_y_r() const;
  public:
  const ::commonroad::FloatExactOrInterval& delta_y_r() const;
  ::commonroad::FloatExactOrInterval* release_delta_y_r();
  ::commonroad::FloatExactOrInterval* mutable_delta_y_r();
  void set_allocated_delta_y_r(::commonroad::FloatExactOrInterval* delta_y_r);

  // optional .commonroad.FloatExactOrInterval acceleration = 32;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 32;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_acceleration() const;
  public:
  const ::commonroad::FloatExactOrInterval& acceleration() const;
  ::commonroad::FloatExactOrInterval* release_acceleration();
  ::commonroad::FloatExactOrInterval* mutable_acceleration();
  void set_allocated_acceleration(::commonroad::FloatExactOrInterval* acceleration);

  // optional .commonroad.FloatExactOrInterval acceleration_y = 33;
  bool has_acceleration_y() const;
  void clear_acceleration_y();
  static const int kAccelerationYFieldNumber = 33;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_acceleration_y() const;
  public:
  const ::commonroad::FloatExactOrInterval& acceleration_y() const;
  ::commonroad::FloatExactOrInterval* release_acceleration_y();
  ::commonroad::FloatExactOrInterval* mutable_acceleration_y();
  void set_allocated_acceleration_y(::commonroad::FloatExactOrInterval* acceleration_y);

  // optional .commonroad.FloatExactOrInterval jerk = 34;
  bool has_jerk() const;
  void clear_jerk();
  static const int kJerkFieldNumber = 34;
  private:
  const ::commonroad::FloatExactOrInterval& _internal_jerk() const;
  public:
  const ::commonroad::FloatExactOrInterval& jerk() const;
  ::commonroad::FloatExactOrInterval* release_jerk();
  ::commonroad::FloatExactOrInterval* mutable_jerk();
  void set_allocated_jerk(::commonroad::FloatExactOrInterval* jerk);

  // optional .commonroad.IntegerExactOrInterval time_step = 35;
  bool has_time_step() const;
  void clear_time_step();
  static const int kTimeStepFieldNumber = 35;
  private:
  const ::commonroad::IntegerExactOrInterval& _internal_time_step() const;
  public:
  const ::commonroad::IntegerExactOrInterval& time_step() const;
  ::commonroad::IntegerExactOrInterval* release_time_step();
  ::commonroad::IntegerExactOrInterval* mutable_time_step();
  void set_allocated_time_step(::commonroad::IntegerExactOrInterval* time_step);

  // optional .commonroad.Point point = 1;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  private:
  const ::commonroad::Point& _internal_point() const;
  public:
  const ::commonroad::Point& point() const;
  ::commonroad::Point* release_point();
  ::commonroad::Point* mutable_point();
  void set_allocated_point(::commonroad::Point* point);

  // optional .commonroad.Shape shape = 2;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 2;
  private:
  const ::commonroad::Shape& _internal_shape() const;
  public:
  const ::commonroad::Shape& shape() const;
  ::commonroad::Shape* release_shape();
  ::commonroad::Shape* mutable_shape();
  void set_allocated_shape(::commonroad::Shape* shape);

  void clear_position();
  PositionCase position_case() const;
  // @@protoc_insertion_point(class_scope:commonroad.State)
 private:
  void set_has_point();
  void set_has_shape();
  void set_has_orientation();
  void clear_has_orientation();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_steering_angle();
  void clear_has_steering_angle();
  void set_has_steering_angle_speed();
  void clear_has_steering_angle_speed();
  void set_has_yaw_rate();
  void clear_has_yaw_rate();
  void set_has_slip_angle();
  void clear_has_slip_angle();
  void set_has_roll_angle();
  void clear_has_roll_angle();
  void set_has_roll_rate();
  void clear_has_roll_rate();
  void set_has_pitch_angle();
  void clear_has_pitch_angle();
  void set_has_pitch_rate();
  void clear_has_pitch_rate();
  void set_has_velocity_y();
  void clear_has_velocity_y();
  void set_has_position_z();
  void clear_has_position_z();
  void set_has_velocity_z();
  void clear_has_velocity_z();
  void set_has_roll_angle_front();
  void clear_has_roll_angle_front();
  void set_has_roll_rate_front();
  void clear_has_roll_rate_front();
  void set_has_velocity_y_front();
  void clear_has_velocity_y_front();
  void set_has_position_z_front();
  void clear_has_position_z_front();
  void set_has_velocity_z_front();
  void clear_has_velocity_z_front();
  void set_has_roll_angle_rear();
  void clear_has_roll_angle_rear();
  void set_has_roll_rate_rear();
  void clear_has_roll_rate_rear();
  void set_has_velocity_y_rear();
  void clear_has_velocity_y_rear();
  void set_has_position_z_rear();
  void clear_has_position_z_rear();
  void set_has_velocity_z_rear();
  void clear_has_velocity_z_rear();
  void set_has_left_front_wheel_angular_speed();
  void clear_has_left_front_wheel_angular_speed();
  void set_has_right_front_wheel_angular_speed();
  void clear_has_right_front_wheel_angular_speed();
  void set_has_left_rear_wheel_angular_speed();
  void clear_has_left_rear_wheel_angular_speed();
  void set_has_right_rear_wheel_angular_speed();
  void clear_has_right_rear_wheel_angular_speed();
  void set_has_delta_y_f();
  void clear_has_delta_y_f();
  void set_has_delta_y_r();
  void clear_has_delta_y_r();
  void set_has_acceleration();
  void clear_has_acceleration();
  void set_has_acceleration_y();
  void clear_has_acceleration_y();
  void set_has_jerk();
  void clear_has_jerk();
  void set_has_time_step();
  void clear_has_time_step();

  inline bool has_position() const;
  inline void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::commonroad::FloatExactOrInterval* orientation_;
  ::commonroad::FloatExactOrInterval* velocity_;
  ::commonroad::FloatExactOrInterval* steering_angle_;
  ::commonroad::FloatExactOrInterval* steering_angle_speed_;
  ::commonroad::FloatExactOrInterval* yaw_rate_;
  ::commonroad::FloatExactOrInterval* slip_angle_;
  ::commonroad::FloatExactOrInterval* roll_angle_;
  ::commonroad::FloatExactOrInterval* roll_rate_;
  ::commonroad::FloatExactOrInterval* pitch_angle_;
  ::commonroad::FloatExactOrInterval* pitch_rate_;
  ::commonroad::FloatExactOrInterval* velocity_y_;
  ::commonroad::FloatExactOrInterval* position_z_;
  ::commonroad::FloatExactOrInterval* velocity_z_;
  ::commonroad::FloatExactOrInterval* roll_angle_front_;
  ::commonroad::FloatExactOrInterval* roll_rate_front_;
  ::commonroad::FloatExactOrInterval* velocity_y_front_;
  ::commonroad::FloatExactOrInterval* position_z_front_;
  ::commonroad::FloatExactOrInterval* velocity_z_front_;
  ::commonroad::FloatExactOrInterval* roll_angle_rear_;
  ::commonroad::FloatExactOrInterval* roll_rate_rear_;
  ::commonroad::FloatExactOrInterval* velocity_y_rear_;
  ::commonroad::FloatExactOrInterval* position_z_rear_;
  ::commonroad::FloatExactOrInterval* velocity_z_rear_;
  ::commonroad::FloatExactOrInterval* left_front_wheel_angular_speed_;
  ::commonroad::FloatExactOrInterval* right_front_wheel_angular_speed_;
  ::commonroad::FloatExactOrInterval* left_rear_wheel_angular_speed_;
  ::commonroad::FloatExactOrInterval* right_rear_wheel_angular_speed_;
  ::commonroad::FloatExactOrInterval* delta_y_f_;
  ::commonroad::FloatExactOrInterval* delta_y_r_;
  ::commonroad::FloatExactOrInterval* acceleration_;
  ::commonroad::FloatExactOrInterval* acceleration_y_;
  ::commonroad::FloatExactOrInterval* jerk_;
  ::commonroad::IntegerExactOrInterval* time_step_;
  union PositionUnion {
    PositionUnion() {}
    ::commonroad::Point* point_;
    ::commonroad::Shape* shape_;
  } position_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_obstacle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignalState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.SignalState) */ {
 public:
  SignalState();
  virtual ~SignalState();

  SignalState(const SignalState& from);

  inline SignalState& operator=(const SignalState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignalState(SignalState&& from) noexcept
    : SignalState() {
    *this = ::std::move(from);
  }

  inline SignalState& operator=(SignalState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalState* internal_default_instance() {
    return reinterpret_cast<const SignalState*>(
               &_SignalState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SignalState* other);
  friend void swap(SignalState& a, SignalState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignalState* New() const final {
    return CreateMaybeMessage<SignalState>(NULL);
  }

  SignalState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignalState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignalState& from);
  void MergeFrom(const SignalState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .commonroad.IntegerExactOrInterval time_step = 1;
  bool has_time_step() const;
  void clear_time_step();
  static const int kTimeStepFieldNumber = 1;
  private:
  const ::commonroad::IntegerExactOrInterval& _internal_time_step() const;
  public:
  const ::commonroad::IntegerExactOrInterval& time_step() const;
  ::commonroad::IntegerExactOrInterval* release_time_step();
  ::commonroad::IntegerExactOrInterval* mutable_time_step();
  void set_allocated_time_step(::commonroad::IntegerExactOrInterval* time_step);

  // optional bool horn = 2;
  bool has_horn() const;
  void clear_horn();
  static const int kHornFieldNumber = 2;
  bool horn() const;
  void set_horn(bool value);

  // optional bool indicator_left = 3;
  bool has_indicator_left() const;
  void clear_indicator_left();
  static const int kIndicatorLeftFieldNumber = 3;
  bool indicator_left() const;
  void set_indicator_left(bool value);

  // optional bool indicator_right = 4;
  bool has_indicator_right() const;
  void clear_indicator_right();
  static const int kIndicatorRightFieldNumber = 4;
  bool indicator_right() const;
  void set_indicator_right(bool value);

  // optional bool braking_lights = 5;
  bool has_braking_lights() const;
  void clear_braking_lights();
  static const int kBrakingLightsFieldNumber = 5;
  bool braking_lights() const;
  void set_braking_lights(bool value);

  // optional bool hazard_warning_lights = 6;
  bool has_hazard_warning_lights() const;
  void clear_hazard_warning_lights();
  static const int kHazardWarningLightsFieldNumber = 6;
  bool hazard_warning_lights() const;
  void set_hazard_warning_lights(bool value);

  // optional bool flashing_blue_lights = 7;
  bool has_flashing_blue_lights() const;
  void clear_flashing_blue_lights();
  static const int kFlashingBlueLightsFieldNumber = 7;
  bool flashing_blue_lights() const;
  void set_flashing_blue_lights(bool value);

  // @@protoc_insertion_point(class_scope:commonroad.SignalState)
 private:
  void set_has_time_step();
  void clear_has_time_step();
  void set_has_horn();
  void clear_has_horn();
  void set_has_indicator_left();
  void clear_has_indicator_left();
  void set_has_indicator_right();
  void clear_has_indicator_right();
  void set_has_braking_lights();
  void clear_has_braking_lights();
  void set_has_hazard_warning_lights();
  void clear_has_hazard_warning_lights();
  void set_has_flashing_blue_lights();
  void clear_has_flashing_blue_lights();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::commonroad::IntegerExactOrInterval* time_step_;
  bool horn_;
  bool indicator_left_;
  bool indicator_right_;
  bool braking_lights_;
  bool hazard_warning_lights_;
  bool flashing_blue_lights_;
  friend struct ::protobuf_obstacle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Occupancy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.Occupancy) */ {
 public:
  Occupancy();
  virtual ~Occupancy();

  Occupancy(const Occupancy& from);

  inline Occupancy& operator=(const Occupancy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Occupancy(Occupancy&& from) noexcept
    : Occupancy() {
    *this = ::std::move(from);
  }

  inline Occupancy& operator=(Occupancy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Occupancy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Occupancy* internal_default_instance() {
    return reinterpret_cast<const Occupancy*>(
               &_Occupancy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Occupancy* other);
  friend void swap(Occupancy& a, Occupancy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Occupancy* New() const final {
    return CreateMaybeMessage<Occupancy>(NULL);
  }

  Occupancy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Occupancy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Occupancy& from);
  void MergeFrom(const Occupancy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Occupancy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .commonroad.IntegerExactOrInterval time_step = 1;
  bool has_time_step() const;
  void clear_time_step();
  static const int kTimeStepFieldNumber = 1;
  private:
  const ::commonroad::IntegerExactOrInterval& _internal_time_step() const;
  public:
  const ::commonroad::IntegerExactOrInterval& time_step() const;
  ::commonroad::IntegerExactOrInterval* release_time_step();
  ::commonroad::IntegerExactOrInterval* mutable_time_step();
  void set_allocated_time_step(::commonroad::IntegerExactOrInterval* time_step);

  // required .commonroad.Shape shape = 2;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 2;
  private:
  const ::commonroad::Shape& _internal_shape() const;
  public:
  const ::commonroad::Shape& shape() const;
  ::commonroad::Shape* release_shape();
  ::commonroad::Shape* mutable_shape();
  void set_allocated_shape(::commonroad::Shape* shape);

  // @@protoc_insertion_point(class_scope:commonroad.Occupancy)
 private:
  void set_has_time_step();
  void clear_has_time_step();
  void set_has_shape();
  void clear_has_shape();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::commonroad::IntegerExactOrInterval* time_step_;
  ::commonroad::Shape* shape_;
  friend struct ::protobuf_obstacle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OccupancySet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.OccupancySet) */ {
 public:
  OccupancySet();
  virtual ~OccupancySet();

  OccupancySet(const OccupancySet& from);

  inline OccupancySet& operator=(const OccupancySet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OccupancySet(OccupancySet&& from) noexcept
    : OccupancySet() {
    *this = ::std::move(from);
  }

  inline OccupancySet& operator=(OccupancySet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OccupancySet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OccupancySet* internal_default_instance() {
    return reinterpret_cast<const OccupancySet*>(
               &_OccupancySet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(OccupancySet* other);
  friend void swap(OccupancySet& a, OccupancySet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OccupancySet* New() const final {
    return CreateMaybeMessage<OccupancySet>(NULL);
  }

  OccupancySet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OccupancySet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OccupancySet& from);
  void MergeFrom(const OccupancySet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OccupancySet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .commonroad.Occupancy occupancies = 1;
  int occupancies_size() const;
  void clear_occupancies();
  static const int kOccupanciesFieldNumber = 1;
  ::commonroad::Occupancy* mutable_occupancies(int index);
  ::google::protobuf::RepeatedPtrField< ::commonroad::Occupancy >*
      mutable_occupancies();
  const ::commonroad::Occupancy& occupancies(int index) const;
  ::commonroad::Occupancy* add_occupancies();
  const ::google::protobuf::RepeatedPtrField< ::commonroad::Occupancy >&
      occupancies() const;

  // @@protoc_insertion_point(class_scope:commonroad.OccupancySet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::commonroad::Occupancy > occupancies_;
  friend struct ::protobuf_obstacle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Trajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.Trajectory) */ {
 public:
  Trajectory();
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Trajectory* other);
  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trajectory* New() const final {
    return CreateMaybeMessage<Trajectory>(NULL);
  }

  Trajectory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Trajectory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .commonroad.State states = 2;
  int states_size() const;
  void clear_states();
  static const int kStatesFieldNumber = 2;
  ::commonroad::State* mutable_states(int index);
  ::google::protobuf::RepeatedPtrField< ::commonroad::State >*
      mutable_states();
  const ::commonroad::State& states(int index) const;
  ::commonroad::State* add_states();
  const ::google::protobuf::RepeatedPtrField< ::commonroad::State >&
      states() const;

  // required uint32 initial_time_step = 1;
  bool has_initial_time_step() const;
  void clear_initial_time_step();
  static const int kInitialTimeStepFieldNumber = 1;
  ::google::protobuf::uint32 initial_time_step() const;
  void set_initial_time_step(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:commonroad.Trajectory)
 private:
  void set_has_initial_time_step();
  void clear_has_initial_time_step();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::commonroad::State > states_;
  ::google::protobuf::uint32 initial_time_step_;
  friend struct ::protobuf_obstacle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrajectoryPrediction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.TrajectoryPrediction) */ {
 public:
  TrajectoryPrediction();
  virtual ~TrajectoryPrediction();

  TrajectoryPrediction(const TrajectoryPrediction& from);

  inline TrajectoryPrediction& operator=(const TrajectoryPrediction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryPrediction(TrajectoryPrediction&& from) noexcept
    : TrajectoryPrediction() {
    *this = ::std::move(from);
  }

  inline TrajectoryPrediction& operator=(TrajectoryPrediction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryPrediction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryPrediction* internal_default_instance() {
    return reinterpret_cast<const TrajectoryPrediction*>(
               &_TrajectoryPrediction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TrajectoryPrediction* other);
  friend void swap(TrajectoryPrediction& a, TrajectoryPrediction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryPrediction* New() const final {
    return CreateMaybeMessage<TrajectoryPrediction>(NULL);
  }

  TrajectoryPrediction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryPrediction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrajectoryPrediction& from);
  void MergeFrom(const TrajectoryPrediction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryPrediction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .commonroad.Trajectory trajectory = 1;
  bool has_trajectory() const;
  void clear_trajectory();
  static const int kTrajectoryFieldNumber = 1;
  private:
  const ::commonroad::Trajectory& _internal_trajectory() const;
  public:
  const ::commonroad::Trajectory& trajectory() const;
  ::commonroad::Trajectory* release_trajectory();
  ::commonroad::Trajectory* mutable_trajectory();
  void set_allocated_trajectory(::commonroad::Trajectory* trajectory);

  // required .commonroad.Shape shape = 2;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 2;
  private:
  const ::commonroad::Shape& _internal_shape() const;
  public:
  const ::commonroad::Shape& shape() const;
  ::commonroad::Shape* release_shape();
  ::commonroad::Shape* mutable_shape();
  void set_allocated_shape(::commonroad::Shape* shape);

  // @@protoc_insertion_point(class_scope:commonroad.TrajectoryPrediction)
 private:
  void set_has_trajectory();
  void clear_has_trajectory();
  void set_has_shape();
  void clear_has_shape();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::commonroad::Trajectory* trajectory_;
  ::commonroad::Shape* shape_;
  friend struct ::protobuf_obstacle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetBasedPrediction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.SetBasedPrediction) */ {
 public:
  SetBasedPrediction();
  virtual ~SetBasedPrediction();

  SetBasedPrediction(const SetBasedPrediction& from);

  inline SetBasedPrediction& operator=(const SetBasedPrediction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetBasedPrediction(SetBasedPrediction&& from) noexcept
    : SetBasedPrediction() {
    *this = ::std::move(from);
  }

  inline SetBasedPrediction& operator=(SetBasedPrediction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetBasedPrediction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetBasedPrediction* internal_default_instance() {
    return reinterpret_cast<const SetBasedPrediction*>(
               &_SetBasedPrediction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SetBasedPrediction* other);
  friend void swap(SetBasedPrediction& a, SetBasedPrediction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetBasedPrediction* New() const final {
    return CreateMaybeMessage<SetBasedPrediction>(NULL);
  }

  SetBasedPrediction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetBasedPrediction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetBasedPrediction& from);
  void MergeFrom(const SetBasedPrediction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetBasedPrediction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .commonroad.OccupancySet occupancy_set = 2;
  bool has_occupancy_set() const;
  void clear_occupancy_set();
  static const int kOccupancySetFieldNumber = 2;
  private:
  const ::commonroad::OccupancySet& _internal_occupancy_set() const;
  public:
  const ::commonroad::OccupancySet& occupancy_set() const;
  ::commonroad::OccupancySet* release_occupancy_set();
  ::commonroad::OccupancySet* mutable_occupancy_set();
  void set_allocated_occupancy_set(::commonroad::OccupancySet* occupancy_set);

  // required uint32 initial_time_step = 1;
  bool has_initial_time_step() const;
  void clear_initial_time_step();
  static const int kInitialTimeStepFieldNumber = 1;
  ::google::protobuf::uint32 initial_time_step() const;
  void set_initial_time_step(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:commonroad.SetBasedPrediction)
 private:
  void set_has_initial_time_step();
  void clear_has_initial_time_step();
  void set_has_occupancy_set();
  void clear_has_occupancy_set();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::commonroad::OccupancySet* occupancy_set_;
  ::google::protobuf::uint32 initial_time_step_;
  friend struct ::protobuf_obstacle_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObstacleTypeEnum

// -------------------------------------------------------------------

// State

// optional .commonroad.Point point = 1;
inline bool State::has_point() const {
  return position_case() == kPoint;
}
inline void State::set_has_point() {
  _oneof_case_[0] = kPoint;
}
inline const ::commonroad::Point& State::_internal_point() const {
  return *position_.point_;
}
inline ::commonroad::Point* State::release_point() {
  // @@protoc_insertion_point(field_release:commonroad.State.point)
  if (has_point()) {
    clear_has_position();
      ::commonroad::Point* temp = position_.point_;
    position_.point_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::commonroad::Point& State::point() const {
  // @@protoc_insertion_point(field_get:commonroad.State.point)
  return has_point()
      ? *position_.point_
      : *reinterpret_cast< ::commonroad::Point*>(&::commonroad::_Point_default_instance_);
}
inline ::commonroad::Point* State::mutable_point() {
  if (!has_point()) {
    clear_position();
    set_has_point();
    position_.point_ = CreateMaybeMessage< ::commonroad::Point >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.point)
  return position_.point_;
}

// optional .commonroad.Shape shape = 2;
inline bool State::has_shape() const {
  return position_case() == kShape;
}
inline void State::set_has_shape() {
  _oneof_case_[0] = kShape;
}
inline const ::commonroad::Shape& State::_internal_shape() const {
  return *position_.shape_;
}
inline ::commonroad::Shape* State::release_shape() {
  // @@protoc_insertion_point(field_release:commonroad.State.shape)
  if (has_shape()) {
    clear_has_position();
      ::commonroad::Shape* temp = position_.shape_;
    position_.shape_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::commonroad::Shape& State::shape() const {
  // @@protoc_insertion_point(field_get:commonroad.State.shape)
  return has_shape()
      ? *position_.shape_
      : *reinterpret_cast< ::commonroad::Shape*>(&::commonroad::_Shape_default_instance_);
}
inline ::commonroad::Shape* State::mutable_shape() {
  if (!has_shape()) {
    clear_position();
    set_has_shape();
    position_.shape_ = CreateMaybeMessage< ::commonroad::Shape >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.shape)
  return position_.shape_;
}

// optional .commonroad.FloatExactOrInterval orientation = 3;
inline bool State::has_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_orientation() const {
  return *orientation_;
}
inline const ::commonroad::FloatExactOrInterval& State::orientation() const {
  const ::commonroad::FloatExactOrInterval* p = orientation_;
  // @@protoc_insertion_point(field_get:commonroad.State.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_orientation() {
  // @@protoc_insertion_point(field_release:commonroad.State.orientation)
  clear_has_orientation();
  ::commonroad::FloatExactOrInterval* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    orientation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.orientation)
  return orientation_;
}
inline void State::set_allocated_orientation(::commonroad::FloatExactOrInterval* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(orientation_);
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.orientation)
}

// optional .commonroad.FloatExactOrInterval velocity = 4;
inline bool State::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_velocity() const {
  return *velocity_;
}
inline const ::commonroad::FloatExactOrInterval& State::velocity() const {
  const ::commonroad::FloatExactOrInterval* p = velocity_;
  // @@protoc_insertion_point(field_get:commonroad.State.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_velocity() {
  // @@protoc_insertion_point(field_release:commonroad.State.velocity)
  clear_has_velocity();
  ::commonroad::FloatExactOrInterval* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.velocity)
  return velocity_;
}
inline void State::set_allocated_velocity(::commonroad::FloatExactOrInterval* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_);
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.velocity)
}

// optional .commonroad.FloatExactOrInterval steering_angle = 5;
inline bool State::has_steering_angle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::set_has_steering_angle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State::clear_has_steering_angle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_steering_angle() const {
  return *steering_angle_;
}
inline const ::commonroad::FloatExactOrInterval& State::steering_angle() const {
  const ::commonroad::FloatExactOrInterval* p = steering_angle_;
  // @@protoc_insertion_point(field_get:commonroad.State.steering_angle)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_steering_angle() {
  // @@protoc_insertion_point(field_release:commonroad.State.steering_angle)
  clear_has_steering_angle();
  ::commonroad::FloatExactOrInterval* temp = steering_angle_;
  steering_angle_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_steering_angle() {
  set_has_steering_angle();
  if (steering_angle_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    steering_angle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.steering_angle)
  return steering_angle_;
}
inline void State::set_allocated_steering_angle(::commonroad::FloatExactOrInterval* steering_angle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(steering_angle_);
  }
  if (steering_angle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      steering_angle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, steering_angle, submessage_arena);
    }
    set_has_steering_angle();
  } else {
    clear_has_steering_angle();
  }
  steering_angle_ = steering_angle;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.steering_angle)
}

// optional .commonroad.FloatExactOrInterval steering_angle_speed = 6;
inline bool State::has_steering_angle_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void State::set_has_steering_angle_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void State::clear_has_steering_angle_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_steering_angle_speed() const {
  return *steering_angle_speed_;
}
inline const ::commonroad::FloatExactOrInterval& State::steering_angle_speed() const {
  const ::commonroad::FloatExactOrInterval* p = steering_angle_speed_;
  // @@protoc_insertion_point(field_get:commonroad.State.steering_angle_speed)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_steering_angle_speed() {
  // @@protoc_insertion_point(field_release:commonroad.State.steering_angle_speed)
  clear_has_steering_angle_speed();
  ::commonroad::FloatExactOrInterval* temp = steering_angle_speed_;
  steering_angle_speed_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_steering_angle_speed() {
  set_has_steering_angle_speed();
  if (steering_angle_speed_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    steering_angle_speed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.steering_angle_speed)
  return steering_angle_speed_;
}
inline void State::set_allocated_steering_angle_speed(::commonroad::FloatExactOrInterval* steering_angle_speed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(steering_angle_speed_);
  }
  if (steering_angle_speed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      steering_angle_speed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, steering_angle_speed, submessage_arena);
    }
    set_has_steering_angle_speed();
  } else {
    clear_has_steering_angle_speed();
  }
  steering_angle_speed_ = steering_angle_speed;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.steering_angle_speed)
}

// optional .commonroad.FloatExactOrInterval yaw_rate = 7;
inline bool State::has_yaw_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void State::set_has_yaw_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void State::clear_has_yaw_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_yaw_rate() const {
  return *yaw_rate_;
}
inline const ::commonroad::FloatExactOrInterval& State::yaw_rate() const {
  const ::commonroad::FloatExactOrInterval* p = yaw_rate_;
  // @@protoc_insertion_point(field_get:commonroad.State.yaw_rate)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_yaw_rate() {
  // @@protoc_insertion_point(field_release:commonroad.State.yaw_rate)
  clear_has_yaw_rate();
  ::commonroad::FloatExactOrInterval* temp = yaw_rate_;
  yaw_rate_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_yaw_rate() {
  set_has_yaw_rate();
  if (yaw_rate_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    yaw_rate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.yaw_rate)
  return yaw_rate_;
}
inline void State::set_allocated_yaw_rate(::commonroad::FloatExactOrInterval* yaw_rate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(yaw_rate_);
  }
  if (yaw_rate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      yaw_rate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw_rate, submessage_arena);
    }
    set_has_yaw_rate();
  } else {
    clear_has_yaw_rate();
  }
  yaw_rate_ = yaw_rate;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.yaw_rate)
}

// optional .commonroad.FloatExactOrInterval slip_angle = 8;
inline bool State::has_slip_angle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void State::set_has_slip_angle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void State::clear_has_slip_angle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_slip_angle() const {
  return *slip_angle_;
}
inline const ::commonroad::FloatExactOrInterval& State::slip_angle() const {
  const ::commonroad::FloatExactOrInterval* p = slip_angle_;
  // @@protoc_insertion_point(field_get:commonroad.State.slip_angle)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_slip_angle() {
  // @@protoc_insertion_point(field_release:commonroad.State.slip_angle)
  clear_has_slip_angle();
  ::commonroad::FloatExactOrInterval* temp = slip_angle_;
  slip_angle_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_slip_angle() {
  set_has_slip_angle();
  if (slip_angle_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    slip_angle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.slip_angle)
  return slip_angle_;
}
inline void State::set_allocated_slip_angle(::commonroad::FloatExactOrInterval* slip_angle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(slip_angle_);
  }
  if (slip_angle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      slip_angle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, slip_angle, submessage_arena);
    }
    set_has_slip_angle();
  } else {
    clear_has_slip_angle();
  }
  slip_angle_ = slip_angle;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.slip_angle)
}

// optional .commonroad.FloatExactOrInterval roll_angle = 9;
inline bool State::has_roll_angle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void State::set_has_roll_angle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void State::clear_has_roll_angle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_roll_angle() const {
  return *roll_angle_;
}
inline const ::commonroad::FloatExactOrInterval& State::roll_angle() const {
  const ::commonroad::FloatExactOrInterval* p = roll_angle_;
  // @@protoc_insertion_point(field_get:commonroad.State.roll_angle)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_roll_angle() {
  // @@protoc_insertion_point(field_release:commonroad.State.roll_angle)
  clear_has_roll_angle();
  ::commonroad::FloatExactOrInterval* temp = roll_angle_;
  roll_angle_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_roll_angle() {
  set_has_roll_angle();
  if (roll_angle_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    roll_angle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.roll_angle)
  return roll_angle_;
}
inline void State::set_allocated_roll_angle(::commonroad::FloatExactOrInterval* roll_angle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_angle_);
  }
  if (roll_angle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roll_angle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll_angle, submessage_arena);
    }
    set_has_roll_angle();
  } else {
    clear_has_roll_angle();
  }
  roll_angle_ = roll_angle;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.roll_angle)
}

// optional .commonroad.FloatExactOrInterval roll_rate = 10;
inline bool State::has_roll_rate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void State::set_has_roll_rate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void State::clear_has_roll_rate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_roll_rate() const {
  return *roll_rate_;
}
inline const ::commonroad::FloatExactOrInterval& State::roll_rate() const {
  const ::commonroad::FloatExactOrInterval* p = roll_rate_;
  // @@protoc_insertion_point(field_get:commonroad.State.roll_rate)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_roll_rate() {
  // @@protoc_insertion_point(field_release:commonroad.State.roll_rate)
  clear_has_roll_rate();
  ::commonroad::FloatExactOrInterval* temp = roll_rate_;
  roll_rate_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_roll_rate() {
  set_has_roll_rate();
  if (roll_rate_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    roll_rate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.roll_rate)
  return roll_rate_;
}
inline void State::set_allocated_roll_rate(::commonroad::FloatExactOrInterval* roll_rate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_rate_);
  }
  if (roll_rate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roll_rate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll_rate, submessage_arena);
    }
    set_has_roll_rate();
  } else {
    clear_has_roll_rate();
  }
  roll_rate_ = roll_rate;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.roll_rate)
}

// optional .commonroad.FloatExactOrInterval pitch_angle = 11;
inline bool State::has_pitch_angle() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void State::set_has_pitch_angle() {
  _has_bits_[0] |= 0x00000100u;
}
inline void State::clear_has_pitch_angle() {
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_pitch_angle() const {
  return *pitch_angle_;
}
inline const ::commonroad::FloatExactOrInterval& State::pitch_angle() const {
  const ::commonroad::FloatExactOrInterval* p = pitch_angle_;
  // @@protoc_insertion_point(field_get:commonroad.State.pitch_angle)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_pitch_angle() {
  // @@protoc_insertion_point(field_release:commonroad.State.pitch_angle)
  clear_has_pitch_angle();
  ::commonroad::FloatExactOrInterval* temp = pitch_angle_;
  pitch_angle_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_pitch_angle() {
  set_has_pitch_angle();
  if (pitch_angle_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    pitch_angle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.pitch_angle)
  return pitch_angle_;
}
inline void State::set_allocated_pitch_angle(::commonroad::FloatExactOrInterval* pitch_angle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pitch_angle_);
  }
  if (pitch_angle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pitch_angle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitch_angle, submessage_arena);
    }
    set_has_pitch_angle();
  } else {
    clear_has_pitch_angle();
  }
  pitch_angle_ = pitch_angle;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.pitch_angle)
}

// optional .commonroad.FloatExactOrInterval pitch_rate = 12;
inline bool State::has_pitch_rate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void State::set_has_pitch_rate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void State::clear_has_pitch_rate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_pitch_rate() const {
  return *pitch_rate_;
}
inline const ::commonroad::FloatExactOrInterval& State::pitch_rate() const {
  const ::commonroad::FloatExactOrInterval* p = pitch_rate_;
  // @@protoc_insertion_point(field_get:commonroad.State.pitch_rate)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_pitch_rate() {
  // @@protoc_insertion_point(field_release:commonroad.State.pitch_rate)
  clear_has_pitch_rate();
  ::commonroad::FloatExactOrInterval* temp = pitch_rate_;
  pitch_rate_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_pitch_rate() {
  set_has_pitch_rate();
  if (pitch_rate_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    pitch_rate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.pitch_rate)
  return pitch_rate_;
}
inline void State::set_allocated_pitch_rate(::commonroad::FloatExactOrInterval* pitch_rate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pitch_rate_);
  }
  if (pitch_rate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pitch_rate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitch_rate, submessage_arena);
    }
    set_has_pitch_rate();
  } else {
    clear_has_pitch_rate();
  }
  pitch_rate_ = pitch_rate;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.pitch_rate)
}

// optional .commonroad.FloatExactOrInterval velocity_y = 13;
inline bool State::has_velocity_y() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void State::set_has_velocity_y() {
  _has_bits_[0] |= 0x00000400u;
}
inline void State::clear_has_velocity_y() {
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_velocity_y() const {
  return *velocity_y_;
}
inline const ::commonroad::FloatExactOrInterval& State::velocity_y() const {
  const ::commonroad::FloatExactOrInterval* p = velocity_y_;
  // @@protoc_insertion_point(field_get:commonroad.State.velocity_y)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_velocity_y() {
  // @@protoc_insertion_point(field_release:commonroad.State.velocity_y)
  clear_has_velocity_y();
  ::commonroad::FloatExactOrInterval* temp = velocity_y_;
  velocity_y_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_velocity_y() {
  set_has_velocity_y();
  if (velocity_y_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    velocity_y_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.velocity_y)
  return velocity_y_;
}
inline void State::set_allocated_velocity_y(::commonroad::FloatExactOrInterval* velocity_y) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_y_);
  }
  if (velocity_y) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity_y = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity_y, submessage_arena);
    }
    set_has_velocity_y();
  } else {
    clear_has_velocity_y();
  }
  velocity_y_ = velocity_y;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.velocity_y)
}

// optional .commonroad.FloatExactOrInterval position_z = 14;
inline bool State::has_position_z() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void State::set_has_position_z() {
  _has_bits_[0] |= 0x00000800u;
}
inline void State::clear_has_position_z() {
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_position_z() const {
  return *position_z_;
}
inline const ::commonroad::FloatExactOrInterval& State::position_z() const {
  const ::commonroad::FloatExactOrInterval* p = position_z_;
  // @@protoc_insertion_point(field_get:commonroad.State.position_z)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_position_z() {
  // @@protoc_insertion_point(field_release:commonroad.State.position_z)
  clear_has_position_z();
  ::commonroad::FloatExactOrInterval* temp = position_z_;
  position_z_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_position_z() {
  set_has_position_z();
  if (position_z_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    position_z_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.position_z)
  return position_z_;
}
inline void State::set_allocated_position_z(::commonroad::FloatExactOrInterval* position_z) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_z_);
  }
  if (position_z) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_z = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_z, submessage_arena);
    }
    set_has_position_z();
  } else {
    clear_has_position_z();
  }
  position_z_ = position_z;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.position_z)
}

// optional .commonroad.FloatExactOrInterval velocity_z = 15;
inline bool State::has_velocity_z() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void State::set_has_velocity_z() {
  _has_bits_[0] |= 0x00001000u;
}
inline void State::clear_has_velocity_z() {
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_velocity_z() const {
  return *velocity_z_;
}
inline const ::commonroad::FloatExactOrInterval& State::velocity_z() const {
  const ::commonroad::FloatExactOrInterval* p = velocity_z_;
  // @@protoc_insertion_point(field_get:commonroad.State.velocity_z)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_velocity_z() {
  // @@protoc_insertion_point(field_release:commonroad.State.velocity_z)
  clear_has_velocity_z();
  ::commonroad::FloatExactOrInterval* temp = velocity_z_;
  velocity_z_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_velocity_z() {
  set_has_velocity_z();
  if (velocity_z_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    velocity_z_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.velocity_z)
  return velocity_z_;
}
inline void State::set_allocated_velocity_z(::commonroad::FloatExactOrInterval* velocity_z) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_z_);
  }
  if (velocity_z) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity_z = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity_z, submessage_arena);
    }
    set_has_velocity_z();
  } else {
    clear_has_velocity_z();
  }
  velocity_z_ = velocity_z;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.velocity_z)
}

// optional .commonroad.FloatExactOrInterval roll_angle_front = 16;
inline bool State::has_roll_angle_front() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void State::set_has_roll_angle_front() {
  _has_bits_[0] |= 0x00002000u;
}
inline void State::clear_has_roll_angle_front() {
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_roll_angle_front() const {
  return *roll_angle_front_;
}
inline const ::commonroad::FloatExactOrInterval& State::roll_angle_front() const {
  const ::commonroad::FloatExactOrInterval* p = roll_angle_front_;
  // @@protoc_insertion_point(field_get:commonroad.State.roll_angle_front)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_roll_angle_front() {
  // @@protoc_insertion_point(field_release:commonroad.State.roll_angle_front)
  clear_has_roll_angle_front();
  ::commonroad::FloatExactOrInterval* temp = roll_angle_front_;
  roll_angle_front_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_roll_angle_front() {
  set_has_roll_angle_front();
  if (roll_angle_front_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    roll_angle_front_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.roll_angle_front)
  return roll_angle_front_;
}
inline void State::set_allocated_roll_angle_front(::commonroad::FloatExactOrInterval* roll_angle_front) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_angle_front_);
  }
  if (roll_angle_front) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roll_angle_front = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll_angle_front, submessage_arena);
    }
    set_has_roll_angle_front();
  } else {
    clear_has_roll_angle_front();
  }
  roll_angle_front_ = roll_angle_front;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.roll_angle_front)
}

// optional .commonroad.FloatExactOrInterval roll_rate_front = 17;
inline bool State::has_roll_rate_front() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void State::set_has_roll_rate_front() {
  _has_bits_[0] |= 0x00004000u;
}
inline void State::clear_has_roll_rate_front() {
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_roll_rate_front() const {
  return *roll_rate_front_;
}
inline const ::commonroad::FloatExactOrInterval& State::roll_rate_front() const {
  const ::commonroad::FloatExactOrInterval* p = roll_rate_front_;
  // @@protoc_insertion_point(field_get:commonroad.State.roll_rate_front)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_roll_rate_front() {
  // @@protoc_insertion_point(field_release:commonroad.State.roll_rate_front)
  clear_has_roll_rate_front();
  ::commonroad::FloatExactOrInterval* temp = roll_rate_front_;
  roll_rate_front_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_roll_rate_front() {
  set_has_roll_rate_front();
  if (roll_rate_front_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    roll_rate_front_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.roll_rate_front)
  return roll_rate_front_;
}
inline void State::set_allocated_roll_rate_front(::commonroad::FloatExactOrInterval* roll_rate_front) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_rate_front_);
  }
  if (roll_rate_front) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roll_rate_front = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll_rate_front, submessage_arena);
    }
    set_has_roll_rate_front();
  } else {
    clear_has_roll_rate_front();
  }
  roll_rate_front_ = roll_rate_front;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.roll_rate_front)
}

// optional .commonroad.FloatExactOrInterval velocity_y_front = 18;
inline bool State::has_velocity_y_front() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void State::set_has_velocity_y_front() {
  _has_bits_[0] |= 0x00008000u;
}
inline void State::clear_has_velocity_y_front() {
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_velocity_y_front() const {
  return *velocity_y_front_;
}
inline const ::commonroad::FloatExactOrInterval& State::velocity_y_front() const {
  const ::commonroad::FloatExactOrInterval* p = velocity_y_front_;
  // @@protoc_insertion_point(field_get:commonroad.State.velocity_y_front)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_velocity_y_front() {
  // @@protoc_insertion_point(field_release:commonroad.State.velocity_y_front)
  clear_has_velocity_y_front();
  ::commonroad::FloatExactOrInterval* temp = velocity_y_front_;
  velocity_y_front_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_velocity_y_front() {
  set_has_velocity_y_front();
  if (velocity_y_front_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    velocity_y_front_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.velocity_y_front)
  return velocity_y_front_;
}
inline void State::set_allocated_velocity_y_front(::commonroad::FloatExactOrInterval* velocity_y_front) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_y_front_);
  }
  if (velocity_y_front) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity_y_front = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity_y_front, submessage_arena);
    }
    set_has_velocity_y_front();
  } else {
    clear_has_velocity_y_front();
  }
  velocity_y_front_ = velocity_y_front;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.velocity_y_front)
}

// optional .commonroad.FloatExactOrInterval position_z_front = 19;
inline bool State::has_position_z_front() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void State::set_has_position_z_front() {
  _has_bits_[0] |= 0x00010000u;
}
inline void State::clear_has_position_z_front() {
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_position_z_front() const {
  return *position_z_front_;
}
inline const ::commonroad::FloatExactOrInterval& State::position_z_front() const {
  const ::commonroad::FloatExactOrInterval* p = position_z_front_;
  // @@protoc_insertion_point(field_get:commonroad.State.position_z_front)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_position_z_front() {
  // @@protoc_insertion_point(field_release:commonroad.State.position_z_front)
  clear_has_position_z_front();
  ::commonroad::FloatExactOrInterval* temp = position_z_front_;
  position_z_front_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_position_z_front() {
  set_has_position_z_front();
  if (position_z_front_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    position_z_front_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.position_z_front)
  return position_z_front_;
}
inline void State::set_allocated_position_z_front(::commonroad::FloatExactOrInterval* position_z_front) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_z_front_);
  }
  if (position_z_front) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_z_front = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_z_front, submessage_arena);
    }
    set_has_position_z_front();
  } else {
    clear_has_position_z_front();
  }
  position_z_front_ = position_z_front;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.position_z_front)
}

// optional .commonroad.FloatExactOrInterval velocity_z_front = 20;
inline bool State::has_velocity_z_front() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void State::set_has_velocity_z_front() {
  _has_bits_[0] |= 0x00020000u;
}
inline void State::clear_has_velocity_z_front() {
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_velocity_z_front() const {
  return *velocity_z_front_;
}
inline const ::commonroad::FloatExactOrInterval& State::velocity_z_front() const {
  const ::commonroad::FloatExactOrInterval* p = velocity_z_front_;
  // @@protoc_insertion_point(field_get:commonroad.State.velocity_z_front)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_velocity_z_front() {
  // @@protoc_insertion_point(field_release:commonroad.State.velocity_z_front)
  clear_has_velocity_z_front();
  ::commonroad::FloatExactOrInterval* temp = velocity_z_front_;
  velocity_z_front_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_velocity_z_front() {
  set_has_velocity_z_front();
  if (velocity_z_front_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    velocity_z_front_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.velocity_z_front)
  return velocity_z_front_;
}
inline void State::set_allocated_velocity_z_front(::commonroad::FloatExactOrInterval* velocity_z_front) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_z_front_);
  }
  if (velocity_z_front) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity_z_front = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity_z_front, submessage_arena);
    }
    set_has_velocity_z_front();
  } else {
    clear_has_velocity_z_front();
  }
  velocity_z_front_ = velocity_z_front;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.velocity_z_front)
}

// optional .commonroad.FloatExactOrInterval roll_angle_rear = 21;
inline bool State::has_roll_angle_rear() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void State::set_has_roll_angle_rear() {
  _has_bits_[0] |= 0x00040000u;
}
inline void State::clear_has_roll_angle_rear() {
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_roll_angle_rear() const {
  return *roll_angle_rear_;
}
inline const ::commonroad::FloatExactOrInterval& State::roll_angle_rear() const {
  const ::commonroad::FloatExactOrInterval* p = roll_angle_rear_;
  // @@protoc_insertion_point(field_get:commonroad.State.roll_angle_rear)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_roll_angle_rear() {
  // @@protoc_insertion_point(field_release:commonroad.State.roll_angle_rear)
  clear_has_roll_angle_rear();
  ::commonroad::FloatExactOrInterval* temp = roll_angle_rear_;
  roll_angle_rear_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_roll_angle_rear() {
  set_has_roll_angle_rear();
  if (roll_angle_rear_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    roll_angle_rear_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.roll_angle_rear)
  return roll_angle_rear_;
}
inline void State::set_allocated_roll_angle_rear(::commonroad::FloatExactOrInterval* roll_angle_rear) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_angle_rear_);
  }
  if (roll_angle_rear) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roll_angle_rear = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll_angle_rear, submessage_arena);
    }
    set_has_roll_angle_rear();
  } else {
    clear_has_roll_angle_rear();
  }
  roll_angle_rear_ = roll_angle_rear;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.roll_angle_rear)
}

// optional .commonroad.FloatExactOrInterval roll_rate_rear = 22;
inline bool State::has_roll_rate_rear() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void State::set_has_roll_rate_rear() {
  _has_bits_[0] |= 0x00080000u;
}
inline void State::clear_has_roll_rate_rear() {
  _has_bits_[0] &= ~0x00080000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_roll_rate_rear() const {
  return *roll_rate_rear_;
}
inline const ::commonroad::FloatExactOrInterval& State::roll_rate_rear() const {
  const ::commonroad::FloatExactOrInterval* p = roll_rate_rear_;
  // @@protoc_insertion_point(field_get:commonroad.State.roll_rate_rear)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_roll_rate_rear() {
  // @@protoc_insertion_point(field_release:commonroad.State.roll_rate_rear)
  clear_has_roll_rate_rear();
  ::commonroad::FloatExactOrInterval* temp = roll_rate_rear_;
  roll_rate_rear_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_roll_rate_rear() {
  set_has_roll_rate_rear();
  if (roll_rate_rear_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    roll_rate_rear_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.roll_rate_rear)
  return roll_rate_rear_;
}
inline void State::set_allocated_roll_rate_rear(::commonroad::FloatExactOrInterval* roll_rate_rear) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_rate_rear_);
  }
  if (roll_rate_rear) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roll_rate_rear = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll_rate_rear, submessage_arena);
    }
    set_has_roll_rate_rear();
  } else {
    clear_has_roll_rate_rear();
  }
  roll_rate_rear_ = roll_rate_rear;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.roll_rate_rear)
}

// optional .commonroad.FloatExactOrInterval velocity_y_rear = 23;
inline bool State::has_velocity_y_rear() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void State::set_has_velocity_y_rear() {
  _has_bits_[0] |= 0x00100000u;
}
inline void State::clear_has_velocity_y_rear() {
  _has_bits_[0] &= ~0x00100000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_velocity_y_rear() const {
  return *velocity_y_rear_;
}
inline const ::commonroad::FloatExactOrInterval& State::velocity_y_rear() const {
  const ::commonroad::FloatExactOrInterval* p = velocity_y_rear_;
  // @@protoc_insertion_point(field_get:commonroad.State.velocity_y_rear)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_velocity_y_rear() {
  // @@protoc_insertion_point(field_release:commonroad.State.velocity_y_rear)
  clear_has_velocity_y_rear();
  ::commonroad::FloatExactOrInterval* temp = velocity_y_rear_;
  velocity_y_rear_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_velocity_y_rear() {
  set_has_velocity_y_rear();
  if (velocity_y_rear_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    velocity_y_rear_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.velocity_y_rear)
  return velocity_y_rear_;
}
inline void State::set_allocated_velocity_y_rear(::commonroad::FloatExactOrInterval* velocity_y_rear) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_y_rear_);
  }
  if (velocity_y_rear) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity_y_rear = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity_y_rear, submessage_arena);
    }
    set_has_velocity_y_rear();
  } else {
    clear_has_velocity_y_rear();
  }
  velocity_y_rear_ = velocity_y_rear;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.velocity_y_rear)
}

// optional .commonroad.FloatExactOrInterval position_z_rear = 24;
inline bool State::has_position_z_rear() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void State::set_has_position_z_rear() {
  _has_bits_[0] |= 0x00200000u;
}
inline void State::clear_has_position_z_rear() {
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_position_z_rear() const {
  return *position_z_rear_;
}
inline const ::commonroad::FloatExactOrInterval& State::position_z_rear() const {
  const ::commonroad::FloatExactOrInterval* p = position_z_rear_;
  // @@protoc_insertion_point(field_get:commonroad.State.position_z_rear)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_position_z_rear() {
  // @@protoc_insertion_point(field_release:commonroad.State.position_z_rear)
  clear_has_position_z_rear();
  ::commonroad::FloatExactOrInterval* temp = position_z_rear_;
  position_z_rear_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_position_z_rear() {
  set_has_position_z_rear();
  if (position_z_rear_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    position_z_rear_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.position_z_rear)
  return position_z_rear_;
}
inline void State::set_allocated_position_z_rear(::commonroad::FloatExactOrInterval* position_z_rear) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_z_rear_);
  }
  if (position_z_rear) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_z_rear = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_z_rear, submessage_arena);
    }
    set_has_position_z_rear();
  } else {
    clear_has_position_z_rear();
  }
  position_z_rear_ = position_z_rear;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.position_z_rear)
}

// optional .commonroad.FloatExactOrInterval velocity_z_rear = 25;
inline bool State::has_velocity_z_rear() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void State::set_has_velocity_z_rear() {
  _has_bits_[0] |= 0x00400000u;
}
inline void State::clear_has_velocity_z_rear() {
  _has_bits_[0] &= ~0x00400000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_velocity_z_rear() const {
  return *velocity_z_rear_;
}
inline const ::commonroad::FloatExactOrInterval& State::velocity_z_rear() const {
  const ::commonroad::FloatExactOrInterval* p = velocity_z_rear_;
  // @@protoc_insertion_point(field_get:commonroad.State.velocity_z_rear)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_velocity_z_rear() {
  // @@protoc_insertion_point(field_release:commonroad.State.velocity_z_rear)
  clear_has_velocity_z_rear();
  ::commonroad::FloatExactOrInterval* temp = velocity_z_rear_;
  velocity_z_rear_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_velocity_z_rear() {
  set_has_velocity_z_rear();
  if (velocity_z_rear_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    velocity_z_rear_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.velocity_z_rear)
  return velocity_z_rear_;
}
inline void State::set_allocated_velocity_z_rear(::commonroad::FloatExactOrInterval* velocity_z_rear) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_z_rear_);
  }
  if (velocity_z_rear) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity_z_rear = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity_z_rear, submessage_arena);
    }
    set_has_velocity_z_rear();
  } else {
    clear_has_velocity_z_rear();
  }
  velocity_z_rear_ = velocity_z_rear;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.velocity_z_rear)
}

// optional .commonroad.FloatExactOrInterval left_front_wheel_angular_speed = 26;
inline bool State::has_left_front_wheel_angular_speed() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void State::set_has_left_front_wheel_angular_speed() {
  _has_bits_[0] |= 0x00800000u;
}
inline void State::clear_has_left_front_wheel_angular_speed() {
  _has_bits_[0] &= ~0x00800000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_left_front_wheel_angular_speed() const {
  return *left_front_wheel_angular_speed_;
}
inline const ::commonroad::FloatExactOrInterval& State::left_front_wheel_angular_speed() const {
  const ::commonroad::FloatExactOrInterval* p = left_front_wheel_angular_speed_;
  // @@protoc_insertion_point(field_get:commonroad.State.left_front_wheel_angular_speed)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_left_front_wheel_angular_speed() {
  // @@protoc_insertion_point(field_release:commonroad.State.left_front_wheel_angular_speed)
  clear_has_left_front_wheel_angular_speed();
  ::commonroad::FloatExactOrInterval* temp = left_front_wheel_angular_speed_;
  left_front_wheel_angular_speed_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_left_front_wheel_angular_speed() {
  set_has_left_front_wheel_angular_speed();
  if (left_front_wheel_angular_speed_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    left_front_wheel_angular_speed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.left_front_wheel_angular_speed)
  return left_front_wheel_angular_speed_;
}
inline void State::set_allocated_left_front_wheel_angular_speed(::commonroad::FloatExactOrInterval* left_front_wheel_angular_speed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(left_front_wheel_angular_speed_);
  }
  if (left_front_wheel_angular_speed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left_front_wheel_angular_speed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left_front_wheel_angular_speed, submessage_arena);
    }
    set_has_left_front_wheel_angular_speed();
  } else {
    clear_has_left_front_wheel_angular_speed();
  }
  left_front_wheel_angular_speed_ = left_front_wheel_angular_speed;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.left_front_wheel_angular_speed)
}

// optional .commonroad.FloatExactOrInterval right_front_wheel_angular_speed = 27;
inline bool State::has_right_front_wheel_angular_speed() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void State::set_has_right_front_wheel_angular_speed() {
  _has_bits_[0] |= 0x01000000u;
}
inline void State::clear_has_right_front_wheel_angular_speed() {
  _has_bits_[0] &= ~0x01000000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_right_front_wheel_angular_speed() const {
  return *right_front_wheel_angular_speed_;
}
inline const ::commonroad::FloatExactOrInterval& State::right_front_wheel_angular_speed() const {
  const ::commonroad::FloatExactOrInterval* p = right_front_wheel_angular_speed_;
  // @@protoc_insertion_point(field_get:commonroad.State.right_front_wheel_angular_speed)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_right_front_wheel_angular_speed() {
  // @@protoc_insertion_point(field_release:commonroad.State.right_front_wheel_angular_speed)
  clear_has_right_front_wheel_angular_speed();
  ::commonroad::FloatExactOrInterval* temp = right_front_wheel_angular_speed_;
  right_front_wheel_angular_speed_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_right_front_wheel_angular_speed() {
  set_has_right_front_wheel_angular_speed();
  if (right_front_wheel_angular_speed_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    right_front_wheel_angular_speed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.right_front_wheel_angular_speed)
  return right_front_wheel_angular_speed_;
}
inline void State::set_allocated_right_front_wheel_angular_speed(::commonroad::FloatExactOrInterval* right_front_wheel_angular_speed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(right_front_wheel_angular_speed_);
  }
  if (right_front_wheel_angular_speed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right_front_wheel_angular_speed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right_front_wheel_angular_speed, submessage_arena);
    }
    set_has_right_front_wheel_angular_speed();
  } else {
    clear_has_right_front_wheel_angular_speed();
  }
  right_front_wheel_angular_speed_ = right_front_wheel_angular_speed;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.right_front_wheel_angular_speed)
}

// optional .commonroad.FloatExactOrInterval left_rear_wheel_angular_speed = 28;
inline bool State::has_left_rear_wheel_angular_speed() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void State::set_has_left_rear_wheel_angular_speed() {
  _has_bits_[0] |= 0x02000000u;
}
inline void State::clear_has_left_rear_wheel_angular_speed() {
  _has_bits_[0] &= ~0x02000000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_left_rear_wheel_angular_speed() const {
  return *left_rear_wheel_angular_speed_;
}
inline const ::commonroad::FloatExactOrInterval& State::left_rear_wheel_angular_speed() const {
  const ::commonroad::FloatExactOrInterval* p = left_rear_wheel_angular_speed_;
  // @@protoc_insertion_point(field_get:commonroad.State.left_rear_wheel_angular_speed)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_left_rear_wheel_angular_speed() {
  // @@protoc_insertion_point(field_release:commonroad.State.left_rear_wheel_angular_speed)
  clear_has_left_rear_wheel_angular_speed();
  ::commonroad::FloatExactOrInterval* temp = left_rear_wheel_angular_speed_;
  left_rear_wheel_angular_speed_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_left_rear_wheel_angular_speed() {
  set_has_left_rear_wheel_angular_speed();
  if (left_rear_wheel_angular_speed_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    left_rear_wheel_angular_speed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.left_rear_wheel_angular_speed)
  return left_rear_wheel_angular_speed_;
}
inline void State::set_allocated_left_rear_wheel_angular_speed(::commonroad::FloatExactOrInterval* left_rear_wheel_angular_speed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(left_rear_wheel_angular_speed_);
  }
  if (left_rear_wheel_angular_speed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left_rear_wheel_angular_speed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left_rear_wheel_angular_speed, submessage_arena);
    }
    set_has_left_rear_wheel_angular_speed();
  } else {
    clear_has_left_rear_wheel_angular_speed();
  }
  left_rear_wheel_angular_speed_ = left_rear_wheel_angular_speed;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.left_rear_wheel_angular_speed)
}

// optional .commonroad.FloatExactOrInterval right_rear_wheel_angular_speed = 29;
inline bool State::has_right_rear_wheel_angular_speed() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void State::set_has_right_rear_wheel_angular_speed() {
  _has_bits_[0] |= 0x04000000u;
}
inline void State::clear_has_right_rear_wheel_angular_speed() {
  _has_bits_[0] &= ~0x04000000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_right_rear_wheel_angular_speed() const {
  return *right_rear_wheel_angular_speed_;
}
inline const ::commonroad::FloatExactOrInterval& State::right_rear_wheel_angular_speed() const {
  const ::commonroad::FloatExactOrInterval* p = right_rear_wheel_angular_speed_;
  // @@protoc_insertion_point(field_get:commonroad.State.right_rear_wheel_angular_speed)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_right_rear_wheel_angular_speed() {
  // @@protoc_insertion_point(field_release:commonroad.State.right_rear_wheel_angular_speed)
  clear_has_right_rear_wheel_angular_speed();
  ::commonroad::FloatExactOrInterval* temp = right_rear_wheel_angular_speed_;
  right_rear_wheel_angular_speed_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_right_rear_wheel_angular_speed() {
  set_has_right_rear_wheel_angular_speed();
  if (right_rear_wheel_angular_speed_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    right_rear_wheel_angular_speed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.right_rear_wheel_angular_speed)
  return right_rear_wheel_angular_speed_;
}
inline void State::set_allocated_right_rear_wheel_angular_speed(::commonroad::FloatExactOrInterval* right_rear_wheel_angular_speed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(right_rear_wheel_angular_speed_);
  }
  if (right_rear_wheel_angular_speed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right_rear_wheel_angular_speed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right_rear_wheel_angular_speed, submessage_arena);
    }
    set_has_right_rear_wheel_angular_speed();
  } else {
    clear_has_right_rear_wheel_angular_speed();
  }
  right_rear_wheel_angular_speed_ = right_rear_wheel_angular_speed;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.right_rear_wheel_angular_speed)
}

// optional .commonroad.FloatExactOrInterval delta_y_f = 30;
inline bool State::has_delta_y_f() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void State::set_has_delta_y_f() {
  _has_bits_[0] |= 0x08000000u;
}
inline void State::clear_has_delta_y_f() {
  _has_bits_[0] &= ~0x08000000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_delta_y_f() const {
  return *delta_y_f_;
}
inline const ::commonroad::FloatExactOrInterval& State::delta_y_f() const {
  const ::commonroad::FloatExactOrInterval* p = delta_y_f_;
  // @@protoc_insertion_point(field_get:commonroad.State.delta_y_f)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_delta_y_f() {
  // @@protoc_insertion_point(field_release:commonroad.State.delta_y_f)
  clear_has_delta_y_f();
  ::commonroad::FloatExactOrInterval* temp = delta_y_f_;
  delta_y_f_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_delta_y_f() {
  set_has_delta_y_f();
  if (delta_y_f_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    delta_y_f_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.delta_y_f)
  return delta_y_f_;
}
inline void State::set_allocated_delta_y_f(::commonroad::FloatExactOrInterval* delta_y_f) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(delta_y_f_);
  }
  if (delta_y_f) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      delta_y_f = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, delta_y_f, submessage_arena);
    }
    set_has_delta_y_f();
  } else {
    clear_has_delta_y_f();
  }
  delta_y_f_ = delta_y_f;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.delta_y_f)
}

// optional .commonroad.FloatExactOrInterval delta_y_r = 31;
inline bool State::has_delta_y_r() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void State::set_has_delta_y_r() {
  _has_bits_[0] |= 0x10000000u;
}
inline void State::clear_has_delta_y_r() {
  _has_bits_[0] &= ~0x10000000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_delta_y_r() const {
  return *delta_y_r_;
}
inline const ::commonroad::FloatExactOrInterval& State::delta_y_r() const {
  const ::commonroad::FloatExactOrInterval* p = delta_y_r_;
  // @@protoc_insertion_point(field_get:commonroad.State.delta_y_r)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_delta_y_r() {
  // @@protoc_insertion_point(field_release:commonroad.State.delta_y_r)
  clear_has_delta_y_r();
  ::commonroad::FloatExactOrInterval* temp = delta_y_r_;
  delta_y_r_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_delta_y_r() {
  set_has_delta_y_r();
  if (delta_y_r_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    delta_y_r_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.delta_y_r)
  return delta_y_r_;
}
inline void State::set_allocated_delta_y_r(::commonroad::FloatExactOrInterval* delta_y_r) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(delta_y_r_);
  }
  if (delta_y_r) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      delta_y_r = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, delta_y_r, submessage_arena);
    }
    set_has_delta_y_r();
  } else {
    clear_has_delta_y_r();
  }
  delta_y_r_ = delta_y_r;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.delta_y_r)
}

// optional .commonroad.FloatExactOrInterval acceleration = 32;
inline bool State::has_acceleration() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void State::set_has_acceleration() {
  _has_bits_[0] |= 0x20000000u;
}
inline void State::clear_has_acceleration() {
  _has_bits_[0] &= ~0x20000000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_acceleration() const {
  return *acceleration_;
}
inline const ::commonroad::FloatExactOrInterval& State::acceleration() const {
  const ::commonroad::FloatExactOrInterval* p = acceleration_;
  // @@protoc_insertion_point(field_get:commonroad.State.acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_acceleration() {
  // @@protoc_insertion_point(field_release:commonroad.State.acceleration)
  clear_has_acceleration();
  ::commonroad::FloatExactOrInterval* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.acceleration)
  return acceleration_;
}
inline void State::set_allocated_acceleration(::commonroad::FloatExactOrInterval* acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(acceleration_);
  }
  if (acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.acceleration)
}

// optional .commonroad.FloatExactOrInterval acceleration_y = 33;
inline bool State::has_acceleration_y() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void State::set_has_acceleration_y() {
  _has_bits_[0] |= 0x40000000u;
}
inline void State::clear_has_acceleration_y() {
  _has_bits_[0] &= ~0x40000000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_acceleration_y() const {
  return *acceleration_y_;
}
inline const ::commonroad::FloatExactOrInterval& State::acceleration_y() const {
  const ::commonroad::FloatExactOrInterval* p = acceleration_y_;
  // @@protoc_insertion_point(field_get:commonroad.State.acceleration_y)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_acceleration_y() {
  // @@protoc_insertion_point(field_release:commonroad.State.acceleration_y)
  clear_has_acceleration_y();
  ::commonroad::FloatExactOrInterval* temp = acceleration_y_;
  acceleration_y_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_acceleration_y() {
  set_has_acceleration_y();
  if (acceleration_y_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    acceleration_y_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.acceleration_y)
  return acceleration_y_;
}
inline void State::set_allocated_acceleration_y(::commonroad::FloatExactOrInterval* acceleration_y) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(acceleration_y_);
  }
  if (acceleration_y) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acceleration_y = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceleration_y, submessage_arena);
    }
    set_has_acceleration_y();
  } else {
    clear_has_acceleration_y();
  }
  acceleration_y_ = acceleration_y;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.acceleration_y)
}

// optional .commonroad.FloatExactOrInterval jerk = 34;
inline bool State::has_jerk() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void State::set_has_jerk() {
  _has_bits_[0] |= 0x80000000u;
}
inline void State::clear_has_jerk() {
  _has_bits_[0] &= ~0x80000000u;
}
inline const ::commonroad::FloatExactOrInterval& State::_internal_jerk() const {
  return *jerk_;
}
inline const ::commonroad::FloatExactOrInterval& State::jerk() const {
  const ::commonroad::FloatExactOrInterval* p = jerk_;
  // @@protoc_insertion_point(field_get:commonroad.State.jerk)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::FloatExactOrInterval*>(
      &::commonroad::_FloatExactOrInterval_default_instance_);
}
inline ::commonroad::FloatExactOrInterval* State::release_jerk() {
  // @@protoc_insertion_point(field_release:commonroad.State.jerk)
  clear_has_jerk();
  ::commonroad::FloatExactOrInterval* temp = jerk_;
  jerk_ = NULL;
  return temp;
}
inline ::commonroad::FloatExactOrInterval* State::mutable_jerk() {
  set_has_jerk();
  if (jerk_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::FloatExactOrInterval>(GetArenaNoVirtual());
    jerk_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.jerk)
  return jerk_;
}
inline void State::set_allocated_jerk(::commonroad::FloatExactOrInterval* jerk) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(jerk_);
  }
  if (jerk) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      jerk = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jerk, submessage_arena);
    }
    set_has_jerk();
  } else {
    clear_has_jerk();
  }
  jerk_ = jerk;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.jerk)
}

// optional .commonroad.IntegerExactOrInterval time_step = 35;
inline bool State::has_time_step() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void State::set_has_time_step() {
  _has_bits_[1] |= 0x00000001u;
}
inline void State::clear_has_time_step() {
  _has_bits_[1] &= ~0x00000001u;
}
inline const ::commonroad::IntegerExactOrInterval& State::_internal_time_step() const {
  return *time_step_;
}
inline const ::commonroad::IntegerExactOrInterval& State::time_step() const {
  const ::commonroad::IntegerExactOrInterval* p = time_step_;
  // @@protoc_insertion_point(field_get:commonroad.State.time_step)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::IntegerExactOrInterval*>(
      &::commonroad::_IntegerExactOrInterval_default_instance_);
}
inline ::commonroad::IntegerExactOrInterval* State::release_time_step() {
  // @@protoc_insertion_point(field_release:commonroad.State.time_step)
  clear_has_time_step();
  ::commonroad::IntegerExactOrInterval* temp = time_step_;
  time_step_ = NULL;
  return temp;
}
inline ::commonroad::IntegerExactOrInterval* State::mutable_time_step() {
  set_has_time_step();
  if (time_step_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::IntegerExactOrInterval>(GetArenaNoVirtual());
    time_step_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.State.time_step)
  return time_step_;
}
inline void State::set_allocated_time_step(::commonroad::IntegerExactOrInterval* time_step) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_step_);
  }
  if (time_step) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time_step = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_step, submessage_arena);
    }
    set_has_time_step();
  } else {
    clear_has_time_step();
  }
  time_step_ = time_step;
  // @@protoc_insertion_point(field_set_allocated:commonroad.State.time_step)
}

inline bool State::has_position() const {
  return position_case() != POSITION_NOT_SET;
}
inline void State::clear_has_position() {
  _oneof_case_[0] = POSITION_NOT_SET;
}
inline State::PositionCase State::position_case() const {
  return State::PositionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SignalState

// optional .commonroad.IntegerExactOrInterval time_step = 1;
inline bool SignalState::has_time_step() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalState::set_has_time_step() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalState::clear_has_time_step() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::commonroad::IntegerExactOrInterval& SignalState::_internal_time_step() const {
  return *time_step_;
}
inline const ::commonroad::IntegerExactOrInterval& SignalState::time_step() const {
  const ::commonroad::IntegerExactOrInterval* p = time_step_;
  // @@protoc_insertion_point(field_get:commonroad.SignalState.time_step)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::IntegerExactOrInterval*>(
      &::commonroad::_IntegerExactOrInterval_default_instance_);
}
inline ::commonroad::IntegerExactOrInterval* SignalState::release_time_step() {
  // @@protoc_insertion_point(field_release:commonroad.SignalState.time_step)
  clear_has_time_step();
  ::commonroad::IntegerExactOrInterval* temp = time_step_;
  time_step_ = NULL;
  return temp;
}
inline ::commonroad::IntegerExactOrInterval* SignalState::mutable_time_step() {
  set_has_time_step();
  if (time_step_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::IntegerExactOrInterval>(GetArenaNoVirtual());
    time_step_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.SignalState.time_step)
  return time_step_;
}
inline void SignalState::set_allocated_time_step(::commonroad::IntegerExactOrInterval* time_step) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_step_);
  }
  if (time_step) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time_step = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_step, submessage_arena);
    }
    set_has_time_step();
  } else {
    clear_has_time_step();
  }
  time_step_ = time_step;
  // @@protoc_insertion_point(field_set_allocated:commonroad.SignalState.time_step)
}

// optional bool horn = 2;
inline bool SignalState::has_horn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalState::set_has_horn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalState::clear_has_horn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalState::clear_horn() {
  horn_ = false;
  clear_has_horn();
}
inline bool SignalState::horn() const {
  // @@protoc_insertion_point(field_get:commonroad.SignalState.horn)
  return horn_;
}
inline void SignalState::set_horn(bool value) {
  set_has_horn();
  horn_ = value;
  // @@protoc_insertion_point(field_set:commonroad.SignalState.horn)
}

// optional bool indicator_left = 3;
inline bool SignalState::has_indicator_left() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalState::set_has_indicator_left() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalState::clear_has_indicator_left() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalState::clear_indicator_left() {
  indicator_left_ = false;
  clear_has_indicator_left();
}
inline bool SignalState::indicator_left() const {
  // @@protoc_insertion_point(field_get:commonroad.SignalState.indicator_left)
  return indicator_left_;
}
inline void SignalState::set_indicator_left(bool value) {
  set_has_indicator_left();
  indicator_left_ = value;
  // @@protoc_insertion_point(field_set:commonroad.SignalState.indicator_left)
}

// optional bool indicator_right = 4;
inline bool SignalState::has_indicator_right() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignalState::set_has_indicator_right() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignalState::clear_has_indicator_right() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignalState::clear_indicator_right() {
  indicator_right_ = false;
  clear_has_indicator_right();
}
inline bool SignalState::indicator_right() const {
  // @@protoc_insertion_point(field_get:commonroad.SignalState.indicator_right)
  return indicator_right_;
}
inline void SignalState::set_indicator_right(bool value) {
  set_has_indicator_right();
  indicator_right_ = value;
  // @@protoc_insertion_point(field_set:commonroad.SignalState.indicator_right)
}

// optional bool braking_lights = 5;
inline bool SignalState::has_braking_lights() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignalState::set_has_braking_lights() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignalState::clear_has_braking_lights() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignalState::clear_braking_lights() {
  braking_lights_ = false;
  clear_has_braking_lights();
}
inline bool SignalState::braking_lights() const {
  // @@protoc_insertion_point(field_get:commonroad.SignalState.braking_lights)
  return braking_lights_;
}
inline void SignalState::set_braking_lights(bool value) {
  set_has_braking_lights();
  braking_lights_ = value;
  // @@protoc_insertion_point(field_set:commonroad.SignalState.braking_lights)
}

// optional bool hazard_warning_lights = 6;
inline bool SignalState::has_hazard_warning_lights() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignalState::set_has_hazard_warning_lights() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignalState::clear_has_hazard_warning_lights() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignalState::clear_hazard_warning_lights() {
  hazard_warning_lights_ = false;
  clear_has_hazard_warning_lights();
}
inline bool SignalState::hazard_warning_lights() const {
  // @@protoc_insertion_point(field_get:commonroad.SignalState.hazard_warning_lights)
  return hazard_warning_lights_;
}
inline void SignalState::set_hazard_warning_lights(bool value) {
  set_has_hazard_warning_lights();
  hazard_warning_lights_ = value;
  // @@protoc_insertion_point(field_set:commonroad.SignalState.hazard_warning_lights)
}

// optional bool flashing_blue_lights = 7;
inline bool SignalState::has_flashing_blue_lights() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignalState::set_has_flashing_blue_lights() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignalState::clear_has_flashing_blue_lights() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignalState::clear_flashing_blue_lights() {
  flashing_blue_lights_ = false;
  clear_has_flashing_blue_lights();
}
inline bool SignalState::flashing_blue_lights() const {
  // @@protoc_insertion_point(field_get:commonroad.SignalState.flashing_blue_lights)
  return flashing_blue_lights_;
}
inline void SignalState::set_flashing_blue_lights(bool value) {
  set_has_flashing_blue_lights();
  flashing_blue_lights_ = value;
  // @@protoc_insertion_point(field_set:commonroad.SignalState.flashing_blue_lights)
}

// -------------------------------------------------------------------

// Occupancy

// required .commonroad.IntegerExactOrInterval time_step = 1;
inline bool Occupancy::has_time_step() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Occupancy::set_has_time_step() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Occupancy::clear_has_time_step() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::commonroad::IntegerExactOrInterval& Occupancy::_internal_time_step() const {
  return *time_step_;
}
inline const ::commonroad::IntegerExactOrInterval& Occupancy::time_step() const {
  const ::commonroad::IntegerExactOrInterval* p = time_step_;
  // @@protoc_insertion_point(field_get:commonroad.Occupancy.time_step)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::IntegerExactOrInterval*>(
      &::commonroad::_IntegerExactOrInterval_default_instance_);
}
inline ::commonroad::IntegerExactOrInterval* Occupancy::release_time_step() {
  // @@protoc_insertion_point(field_release:commonroad.Occupancy.time_step)
  clear_has_time_step();
  ::commonroad::IntegerExactOrInterval* temp = time_step_;
  time_step_ = NULL;
  return temp;
}
inline ::commonroad::IntegerExactOrInterval* Occupancy::mutable_time_step() {
  set_has_time_step();
  if (time_step_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::IntegerExactOrInterval>(GetArenaNoVirtual());
    time_step_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Occupancy.time_step)
  return time_step_;
}
inline void Occupancy::set_allocated_time_step(::commonroad::IntegerExactOrInterval* time_step) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_step_);
  }
  if (time_step) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time_step = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_step, submessage_arena);
    }
    set_has_time_step();
  } else {
    clear_has_time_step();
  }
  time_step_ = time_step;
  // @@protoc_insertion_point(field_set_allocated:commonroad.Occupancy.time_step)
}

// required .commonroad.Shape shape = 2;
inline bool Occupancy::has_shape() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Occupancy::set_has_shape() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Occupancy::clear_has_shape() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::commonroad::Shape& Occupancy::_internal_shape() const {
  return *shape_;
}
inline const ::commonroad::Shape& Occupancy::shape() const {
  const ::commonroad::Shape* p = shape_;
  // @@protoc_insertion_point(field_get:commonroad.Occupancy.shape)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::Shape*>(
      &::commonroad::_Shape_default_instance_);
}
inline ::commonroad::Shape* Occupancy::release_shape() {
  // @@protoc_insertion_point(field_release:commonroad.Occupancy.shape)
  clear_has_shape();
  ::commonroad::Shape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline ::commonroad::Shape* Occupancy::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::Shape>(GetArenaNoVirtual());
    shape_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Occupancy.shape)
  return shape_;
}
inline void Occupancy::set_allocated_shape(::commonroad::Shape* shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(shape_);
  }
  if (shape) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    set_has_shape();
  } else {
    clear_has_shape();
  }
  shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:commonroad.Occupancy.shape)
}

// -------------------------------------------------------------------

// OccupancySet

// repeated .commonroad.Occupancy occupancies = 1;
inline int OccupancySet::occupancies_size() const {
  return occupancies_.size();
}
inline void OccupancySet::clear_occupancies() {
  occupancies_.Clear();
}
inline ::commonroad::Occupancy* OccupancySet::mutable_occupancies(int index) {
  // @@protoc_insertion_point(field_mutable:commonroad.OccupancySet.occupancies)
  return occupancies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::commonroad::Occupancy >*
OccupancySet::mutable_occupancies() {
  // @@protoc_insertion_point(field_mutable_list:commonroad.OccupancySet.occupancies)
  return &occupancies_;
}
inline const ::commonroad::Occupancy& OccupancySet::occupancies(int index) const {
  // @@protoc_insertion_point(field_get:commonroad.OccupancySet.occupancies)
  return occupancies_.Get(index);
}
inline ::commonroad::Occupancy* OccupancySet::add_occupancies() {
  // @@protoc_insertion_point(field_add:commonroad.OccupancySet.occupancies)
  return occupancies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::commonroad::Occupancy >&
OccupancySet::occupancies() const {
  // @@protoc_insertion_point(field_list:commonroad.OccupancySet.occupancies)
  return occupancies_;
}

// -------------------------------------------------------------------

// Trajectory

// required uint32 initial_time_step = 1;
inline bool Trajectory::has_initial_time_step() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trajectory::set_has_initial_time_step() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trajectory::clear_has_initial_time_step() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trajectory::clear_initial_time_step() {
  initial_time_step_ = 0u;
  clear_has_initial_time_step();
}
inline ::google::protobuf::uint32 Trajectory::initial_time_step() const {
  // @@protoc_insertion_point(field_get:commonroad.Trajectory.initial_time_step)
  return initial_time_step_;
}
inline void Trajectory::set_initial_time_step(::google::protobuf::uint32 value) {
  set_has_initial_time_step();
  initial_time_step_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Trajectory.initial_time_step)
}

// repeated .commonroad.State states = 2;
inline int Trajectory::states_size() const {
  return states_.size();
}
inline void Trajectory::clear_states() {
  states_.Clear();
}
inline ::commonroad::State* Trajectory::mutable_states(int index) {
  // @@protoc_insertion_point(field_mutable:commonroad.Trajectory.states)
  return states_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::commonroad::State >*
Trajectory::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:commonroad.Trajectory.states)
  return &states_;
}
inline const ::commonroad::State& Trajectory::states(int index) const {
  // @@protoc_insertion_point(field_get:commonroad.Trajectory.states)
  return states_.Get(index);
}
inline ::commonroad::State* Trajectory::add_states() {
  // @@protoc_insertion_point(field_add:commonroad.Trajectory.states)
  return states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::commonroad::State >&
Trajectory::states() const {
  // @@protoc_insertion_point(field_list:commonroad.Trajectory.states)
  return states_;
}

// -------------------------------------------------------------------

// TrajectoryPrediction

// required .commonroad.Trajectory trajectory = 1;
inline bool TrajectoryPrediction::has_trajectory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrajectoryPrediction::set_has_trajectory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrajectoryPrediction::clear_has_trajectory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrajectoryPrediction::clear_trajectory() {
  if (trajectory_ != NULL) trajectory_->Clear();
  clear_has_trajectory();
}
inline const ::commonroad::Trajectory& TrajectoryPrediction::_internal_trajectory() const {
  return *trajectory_;
}
inline const ::commonroad::Trajectory& TrajectoryPrediction::trajectory() const {
  const ::commonroad::Trajectory* p = trajectory_;
  // @@protoc_insertion_point(field_get:commonroad.TrajectoryPrediction.trajectory)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::Trajectory*>(
      &::commonroad::_Trajectory_default_instance_);
}
inline ::commonroad::Trajectory* TrajectoryPrediction::release_trajectory() {
  // @@protoc_insertion_point(field_release:commonroad.TrajectoryPrediction.trajectory)
  clear_has_trajectory();
  ::commonroad::Trajectory* temp = trajectory_;
  trajectory_ = NULL;
  return temp;
}
inline ::commonroad::Trajectory* TrajectoryPrediction::mutable_trajectory() {
  set_has_trajectory();
  if (trajectory_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::Trajectory>(GetArenaNoVirtual());
    trajectory_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.TrajectoryPrediction.trajectory)
  return trajectory_;
}
inline void TrajectoryPrediction::set_allocated_trajectory(::commonroad::Trajectory* trajectory) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trajectory_;
  }
  if (trajectory) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory, submessage_arena);
    }
    set_has_trajectory();
  } else {
    clear_has_trajectory();
  }
  trajectory_ = trajectory;
  // @@protoc_insertion_point(field_set_allocated:commonroad.TrajectoryPrediction.trajectory)
}

// required .commonroad.Shape shape = 2;
inline bool TrajectoryPrediction::has_shape() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrajectoryPrediction::set_has_shape() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrajectoryPrediction::clear_has_shape() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::commonroad::Shape& TrajectoryPrediction::_internal_shape() const {
  return *shape_;
}
inline const ::commonroad::Shape& TrajectoryPrediction::shape() const {
  const ::commonroad::Shape* p = shape_;
  // @@protoc_insertion_point(field_get:commonroad.TrajectoryPrediction.shape)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::Shape*>(
      &::commonroad::_Shape_default_instance_);
}
inline ::commonroad::Shape* TrajectoryPrediction::release_shape() {
  // @@protoc_insertion_point(field_release:commonroad.TrajectoryPrediction.shape)
  clear_has_shape();
  ::commonroad::Shape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline ::commonroad::Shape* TrajectoryPrediction::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::Shape>(GetArenaNoVirtual());
    shape_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.TrajectoryPrediction.shape)
  return shape_;
}
inline void TrajectoryPrediction::set_allocated_shape(::commonroad::Shape* shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(shape_);
  }
  if (shape) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    set_has_shape();
  } else {
    clear_has_shape();
  }
  shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:commonroad.TrajectoryPrediction.shape)
}

// -------------------------------------------------------------------

// SetBasedPrediction

// required uint32 initial_time_step = 1;
inline bool SetBasedPrediction::has_initial_time_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetBasedPrediction::set_has_initial_time_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetBasedPrediction::clear_has_initial_time_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetBasedPrediction::clear_initial_time_step() {
  initial_time_step_ = 0u;
  clear_has_initial_time_step();
}
inline ::google::protobuf::uint32 SetBasedPrediction::initial_time_step() const {
  // @@protoc_insertion_point(field_get:commonroad.SetBasedPrediction.initial_time_step)
  return initial_time_step_;
}
inline void SetBasedPrediction::set_initial_time_step(::google::protobuf::uint32 value) {
  set_has_initial_time_step();
  initial_time_step_ = value;
  // @@protoc_insertion_point(field_set:commonroad.SetBasedPrediction.initial_time_step)
}

// required .commonroad.OccupancySet occupancy_set = 2;
inline bool SetBasedPrediction::has_occupancy_set() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetBasedPrediction::set_has_occupancy_set() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetBasedPrediction::clear_has_occupancy_set() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetBasedPrediction::clear_occupancy_set() {
  if (occupancy_set_ != NULL) occupancy_set_->Clear();
  clear_has_occupancy_set();
}
inline const ::commonroad::OccupancySet& SetBasedPrediction::_internal_occupancy_set() const {
  return *occupancy_set_;
}
inline const ::commonroad::OccupancySet& SetBasedPrediction::occupancy_set() const {
  const ::commonroad::OccupancySet* p = occupancy_set_;
  // @@protoc_insertion_point(field_get:commonroad.SetBasedPrediction.occupancy_set)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::OccupancySet*>(
      &::commonroad::_OccupancySet_default_instance_);
}
inline ::commonroad::OccupancySet* SetBasedPrediction::release_occupancy_set() {
  // @@protoc_insertion_point(field_release:commonroad.SetBasedPrediction.occupancy_set)
  clear_has_occupancy_set();
  ::commonroad::OccupancySet* temp = occupancy_set_;
  occupancy_set_ = NULL;
  return temp;
}
inline ::commonroad::OccupancySet* SetBasedPrediction::mutable_occupancy_set() {
  set_has_occupancy_set();
  if (occupancy_set_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::OccupancySet>(GetArenaNoVirtual());
    occupancy_set_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.SetBasedPrediction.occupancy_set)
  return occupancy_set_;
}
inline void SetBasedPrediction::set_allocated_occupancy_set(::commonroad::OccupancySet* occupancy_set) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete occupancy_set_;
  }
  if (occupancy_set) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      occupancy_set = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, occupancy_set, submessage_arena);
    }
    set_has_occupancy_set();
  } else {
    clear_has_occupancy_set();
  }
  occupancy_set_ = occupancy_set;
  // @@protoc_insertion_point(field_set_allocated:commonroad.SetBasedPrediction.occupancy_set)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commonroad

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::commonroad::ObstacleTypeEnum_ObstacleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commonroad::ObstacleTypeEnum_ObstacleType>() {
  return ::commonroad::ObstacleTypeEnum_ObstacleType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_obstacle_2eproto
