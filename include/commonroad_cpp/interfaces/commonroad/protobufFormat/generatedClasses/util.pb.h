// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: util.proto

#ifndef PROTOBUF_INCLUDED_util_2eproto
#define PROTOBUF_INCLUDED_util_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_util_2eproto 

namespace protobuf_util_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_util_2eproto
namespace commonroad {
class Circle;
class CircleDefaultTypeInternal;
extern CircleDefaultTypeInternal _Circle_default_instance_;
class FloatExactOrInterval;
class FloatExactOrIntervalDefaultTypeInternal;
extern FloatExactOrIntervalDefaultTypeInternal _FloatExactOrInterval_default_instance_;
class FloatInterval;
class FloatIntervalDefaultTypeInternal;
extern FloatIntervalDefaultTypeInternal _FloatInterval_default_instance_;
class FloatList;
class FloatListDefaultTypeInternal;
extern FloatListDefaultTypeInternal _FloatList_default_instance_;
class IntegerExactOrInterval;
class IntegerExactOrIntervalDefaultTypeInternal;
extern IntegerExactOrIntervalDefaultTypeInternal _IntegerExactOrInterval_default_instance_;
class IntegerInterval;
class IntegerIntervalDefaultTypeInternal;
extern IntegerIntervalDefaultTypeInternal _IntegerInterval_default_instance_;
class IntegerList;
class IntegerListDefaultTypeInternal;
extern IntegerListDefaultTypeInternal _IntegerList_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Rectangle;
class RectangleDefaultTypeInternal;
extern RectangleDefaultTypeInternal _Rectangle_default_instance_;
class Shape;
class ShapeDefaultTypeInternal;
extern ShapeDefaultTypeInternal _Shape_default_instance_;
class ShapeGroup;
class ShapeGroupDefaultTypeInternal;
extern ShapeGroupDefaultTypeInternal _ShapeGroup_default_instance_;
class TimeStamp;
class TimeStampDefaultTypeInternal;
extern TimeStampDefaultTypeInternal _TimeStamp_default_instance_;
}  // namespace commonroad
namespace google {
namespace protobuf {
template<> ::commonroad::Circle* Arena::CreateMaybeMessage<::commonroad::Circle>(Arena*);
template<> ::commonroad::FloatExactOrInterval* Arena::CreateMaybeMessage<::commonroad::FloatExactOrInterval>(Arena*);
template<> ::commonroad::FloatInterval* Arena::CreateMaybeMessage<::commonroad::FloatInterval>(Arena*);
template<> ::commonroad::FloatList* Arena::CreateMaybeMessage<::commonroad::FloatList>(Arena*);
template<> ::commonroad::IntegerExactOrInterval* Arena::CreateMaybeMessage<::commonroad::IntegerExactOrInterval>(Arena*);
template<> ::commonroad::IntegerInterval* Arena::CreateMaybeMessage<::commonroad::IntegerInterval>(Arena*);
template<> ::commonroad::IntegerList* Arena::CreateMaybeMessage<::commonroad::IntegerList>(Arena*);
template<> ::commonroad::Point* Arena::CreateMaybeMessage<::commonroad::Point>(Arena*);
template<> ::commonroad::Polygon* Arena::CreateMaybeMessage<::commonroad::Polygon>(Arena*);
template<> ::commonroad::Rectangle* Arena::CreateMaybeMessage<::commonroad::Rectangle>(Arena*);
template<> ::commonroad::Shape* Arena::CreateMaybeMessage<::commonroad::Shape>(Arena*);
template<> ::commonroad::ShapeGroup* Arena::CreateMaybeMessage<::commonroad::ShapeGroup>(Arena*);
template<> ::commonroad::TimeStamp* Arena::CreateMaybeMessage<::commonroad::TimeStamp>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace commonroad {

// ===================================================================

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(NULL);
  }

  Point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // @@protoc_insertion_point(class_scope:commonroad.Point)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rectangle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.Rectangle) */ {
 public:
  Rectangle();
  virtual ~Rectangle();

  Rectangle(const Rectangle& from);

  inline Rectangle& operator=(const Rectangle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rectangle(Rectangle&& from) noexcept
    : Rectangle() {
    *this = ::std::move(from);
  }

  inline Rectangle& operator=(Rectangle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rectangle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rectangle* internal_default_instance() {
    return reinterpret_cast<const Rectangle*>(
               &_Rectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Rectangle* other);
  friend void swap(Rectangle& a, Rectangle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rectangle* New() const final {
    return CreateMaybeMessage<Rectangle>(NULL);
  }

  Rectangle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rectangle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Rectangle& from);
  void MergeFrom(const Rectangle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rectangle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .commonroad.Point center = 3;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 3;
  private:
  const ::commonroad::Point& _internal_center() const;
  public:
  const ::commonroad::Point& center() const;
  ::commonroad::Point* release_center();
  ::commonroad::Point* mutable_center();
  void set_allocated_center(::commonroad::Point* center);

  // required double length = 1;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 1;
  double length() const;
  void set_length(double value);

  // required double width = 2;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  double width() const;
  void set_width(double value);

  // optional double orientation = 4;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  double orientation() const;
  void set_orientation(double value);

  // @@protoc_insertion_point(class_scope:commonroad.Rectangle)
 private:
  void set_has_length();
  void clear_has_length();
  void set_has_width();
  void clear_has_width();
  void set_has_center();
  void clear_has_center();
  void set_has_orientation();
  void clear_has_orientation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::commonroad::Point* center_;
  double length_;
  double width_;
  double orientation_;
  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Circle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.Circle) */ {
 public:
  Circle();
  virtual ~Circle();

  Circle(const Circle& from);

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Circle(Circle&& from) noexcept
    : Circle() {
    *this = ::std::move(from);
  }

  inline Circle& operator=(Circle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Circle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Circle* internal_default_instance() {
    return reinterpret_cast<const Circle*>(
               &_Circle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Circle* other);
  friend void swap(Circle& a, Circle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Circle* New() const final {
    return CreateMaybeMessage<Circle>(NULL);
  }

  Circle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Circle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Circle& from);
  void MergeFrom(const Circle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Circle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .commonroad.Point center = 2;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 2;
  private:
  const ::commonroad::Point& _internal_center() const;
  public:
  const ::commonroad::Point& center() const;
  ::commonroad::Point* release_center();
  ::commonroad::Point* mutable_center();
  void set_allocated_center(::commonroad::Point* center);

  // required double radius = 1;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  double radius() const;
  void set_radius(double value);

  // @@protoc_insertion_point(class_scope:commonroad.Circle)
 private:
  void set_has_radius();
  void clear_has_radius();
  void set_has_center();
  void clear_has_center();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::commonroad::Point* center_;
  double radius_;
  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.Polygon) */ {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Polygon* other);
  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const final {
    return CreateMaybeMessage<Polygon>(NULL);
  }

  Polygon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .commonroad.Point vertices = 1;
  int vertices_size() const;
  void clear_vertices();
  static const int kVerticesFieldNumber = 1;
  ::commonroad::Point* mutable_vertices(int index);
  ::google::protobuf::RepeatedPtrField< ::commonroad::Point >*
      mutable_vertices();
  const ::commonroad::Point& vertices(int index) const;
  ::commonroad::Point* add_vertices();
  const ::google::protobuf::RepeatedPtrField< ::commonroad::Point >&
      vertices() const;

  // @@protoc_insertion_point(class_scope:commonroad.Polygon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::commonroad::Point > vertices_;
  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShapeGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.ShapeGroup) */ {
 public:
  ShapeGroup();
  virtual ~ShapeGroup();

  ShapeGroup(const ShapeGroup& from);

  inline ShapeGroup& operator=(const ShapeGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShapeGroup(ShapeGroup&& from) noexcept
    : ShapeGroup() {
    *this = ::std::move(from);
  }

  inline ShapeGroup& operator=(ShapeGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShapeGroup* internal_default_instance() {
    return reinterpret_cast<const ShapeGroup*>(
               &_ShapeGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ShapeGroup* other);
  friend void swap(ShapeGroup& a, ShapeGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShapeGroup* New() const final {
    return CreateMaybeMessage<ShapeGroup>(NULL);
  }

  ShapeGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShapeGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ShapeGroup& from);
  void MergeFrom(const ShapeGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .commonroad.Shape shapes = 1;
  int shapes_size() const;
  void clear_shapes();
  static const int kShapesFieldNumber = 1;
  ::commonroad::Shape* mutable_shapes(int index);
  ::google::protobuf::RepeatedPtrField< ::commonroad::Shape >*
      mutable_shapes();
  const ::commonroad::Shape& shapes(int index) const;
  ::commonroad::Shape* add_shapes();
  const ::google::protobuf::RepeatedPtrField< ::commonroad::Shape >&
      shapes() const;

  // @@protoc_insertion_point(class_scope:commonroad.ShapeGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::commonroad::Shape > shapes_;
  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Shape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.Shape) */ {
 public:
  Shape();
  virtual ~Shape();

  Shape(const Shape& from);

  inline Shape& operator=(const Shape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Shape(Shape&& from) noexcept
    : Shape() {
    *this = ::std::move(from);
  }

  inline Shape& operator=(Shape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shape& default_instance();

  enum ShapeCase {
    kRectangle = 1,
    kCircle = 2,
    kPolygon = 3,
    kShapeGroup = 4,
    SHAPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Shape* internal_default_instance() {
    return reinterpret_cast<const Shape*>(
               &_Shape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Shape* other);
  friend void swap(Shape& a, Shape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Shape* New() const final {
    return CreateMaybeMessage<Shape>(NULL);
  }

  Shape* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Shape>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Shape& from);
  void MergeFrom(const Shape& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .commonroad.Rectangle rectangle = 1;
  bool has_rectangle() const;
  void clear_rectangle();
  static const int kRectangleFieldNumber = 1;
  private:
  const ::commonroad::Rectangle& _internal_rectangle() const;
  public:
  const ::commonroad::Rectangle& rectangle() const;
  ::commonroad::Rectangle* release_rectangle();
  ::commonroad::Rectangle* mutable_rectangle();
  void set_allocated_rectangle(::commonroad::Rectangle* rectangle);

  // optional .commonroad.Circle circle = 2;
  bool has_circle() const;
  void clear_circle();
  static const int kCircleFieldNumber = 2;
  private:
  const ::commonroad::Circle& _internal_circle() const;
  public:
  const ::commonroad::Circle& circle() const;
  ::commonroad::Circle* release_circle();
  ::commonroad::Circle* mutable_circle();
  void set_allocated_circle(::commonroad::Circle* circle);

  // optional .commonroad.Polygon polygon = 3;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 3;
  private:
  const ::commonroad::Polygon& _internal_polygon() const;
  public:
  const ::commonroad::Polygon& polygon() const;
  ::commonroad::Polygon* release_polygon();
  ::commonroad::Polygon* mutable_polygon();
  void set_allocated_polygon(::commonroad::Polygon* polygon);

  // optional .commonroad.ShapeGroup shape_group = 4;
  bool has_shape_group() const;
  void clear_shape_group();
  static const int kShapeGroupFieldNumber = 4;
  private:
  const ::commonroad::ShapeGroup& _internal_shape_group() const;
  public:
  const ::commonroad::ShapeGroup& shape_group() const;
  ::commonroad::ShapeGroup* release_shape_group();
  ::commonroad::ShapeGroup* mutable_shape_group();
  void set_allocated_shape_group(::commonroad::ShapeGroup* shape_group);

  void clear_shape();
  ShapeCase shape_case() const;
  // @@protoc_insertion_point(class_scope:commonroad.Shape)
 private:
  void set_has_rectangle();
  void set_has_circle();
  void set_has_polygon();
  void set_has_shape_group();

  inline bool has_shape() const;
  inline void clear_has_shape();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ShapeUnion {
    ShapeUnion() {}
    ::commonroad::Rectangle* rectangle_;
    ::commonroad::Circle* circle_;
    ::commonroad::Polygon* polygon_;
    ::commonroad::ShapeGroup* shape_group_;
  } shape_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IntegerInterval : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.IntegerInterval) */ {
 public:
  IntegerInterval();
  virtual ~IntegerInterval();

  IntegerInterval(const IntegerInterval& from);

  inline IntegerInterval& operator=(const IntegerInterval& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntegerInterval(IntegerInterval&& from) noexcept
    : IntegerInterval() {
    *this = ::std::move(from);
  }

  inline IntegerInterval& operator=(IntegerInterval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegerInterval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntegerInterval* internal_default_instance() {
    return reinterpret_cast<const IntegerInterval*>(
               &_IntegerInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(IntegerInterval* other);
  friend void swap(IntegerInterval& a, IntegerInterval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntegerInterval* New() const final {
    return CreateMaybeMessage<IntegerInterval>(NULL);
  }

  IntegerInterval* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IntegerInterval>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IntegerInterval& from);
  void MergeFrom(const IntegerInterval& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerInterval* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // required int32 end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:commonroad.IntegerInterval)
 private:
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FloatInterval : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.FloatInterval) */ {
 public:
  FloatInterval();
  virtual ~FloatInterval();

  FloatInterval(const FloatInterval& from);

  inline FloatInterval& operator=(const FloatInterval& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatInterval(FloatInterval&& from) noexcept
    : FloatInterval() {
    *this = ::std::move(from);
  }

  inline FloatInterval& operator=(FloatInterval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatInterval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatInterval* internal_default_instance() {
    return reinterpret_cast<const FloatInterval*>(
               &_FloatInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(FloatInterval* other);
  friend void swap(FloatInterval& a, FloatInterval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatInterval* New() const final {
    return CreateMaybeMessage<FloatInterval>(NULL);
  }

  FloatInterval* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FloatInterval>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FloatInterval& from);
  void MergeFrom(const FloatInterval& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatInterval* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  double start() const;
  void set_start(double value);

  // required double end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  double end() const;
  void set_end(double value);

  // @@protoc_insertion_point(class_scope:commonroad.FloatInterval)
 private:
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double start_;
  double end_;
  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IntegerExactOrInterval : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.IntegerExactOrInterval) */ {
 public:
  IntegerExactOrInterval();
  virtual ~IntegerExactOrInterval();

  IntegerExactOrInterval(const IntegerExactOrInterval& from);

  inline IntegerExactOrInterval& operator=(const IntegerExactOrInterval& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntegerExactOrInterval(IntegerExactOrInterval&& from) noexcept
    : IntegerExactOrInterval() {
    *this = ::std::move(from);
  }

  inline IntegerExactOrInterval& operator=(IntegerExactOrInterval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegerExactOrInterval& default_instance();

  enum ExactOrIntervalCase {
    kExact = 1,
    kInterval = 2,
    EXACT_OR_INTERVAL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntegerExactOrInterval* internal_default_instance() {
    return reinterpret_cast<const IntegerExactOrInterval*>(
               &_IntegerExactOrInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(IntegerExactOrInterval* other);
  friend void swap(IntegerExactOrInterval& a, IntegerExactOrInterval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntegerExactOrInterval* New() const final {
    return CreateMaybeMessage<IntegerExactOrInterval>(NULL);
  }

  IntegerExactOrInterval* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IntegerExactOrInterval>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IntegerExactOrInterval& from);
  void MergeFrom(const IntegerExactOrInterval& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerExactOrInterval* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 exact = 1;
  bool has_exact() const;
  void clear_exact();
  static const int kExactFieldNumber = 1;
  ::google::protobuf::int32 exact() const;
  void set_exact(::google::protobuf::int32 value);

  // optional .commonroad.IntegerInterval interval = 2;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 2;
  private:
  const ::commonroad::IntegerInterval& _internal_interval() const;
  public:
  const ::commonroad::IntegerInterval& interval() const;
  ::commonroad::IntegerInterval* release_interval();
  ::commonroad::IntegerInterval* mutable_interval();
  void set_allocated_interval(::commonroad::IntegerInterval* interval);

  void clear_exact_or_interval();
  ExactOrIntervalCase exact_or_interval_case() const;
  // @@protoc_insertion_point(class_scope:commonroad.IntegerExactOrInterval)
 private:
  void set_has_exact();
  void set_has_interval();

  inline bool has_exact_or_interval() const;
  inline void clear_has_exact_or_interval();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ExactOrIntervalUnion {
    ExactOrIntervalUnion() {}
    ::google::protobuf::int32 exact_;
    ::commonroad::IntegerInterval* interval_;
  } exact_or_interval_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FloatExactOrInterval : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.FloatExactOrInterval) */ {
 public:
  FloatExactOrInterval();
  virtual ~FloatExactOrInterval();

  FloatExactOrInterval(const FloatExactOrInterval& from);

  inline FloatExactOrInterval& operator=(const FloatExactOrInterval& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatExactOrInterval(FloatExactOrInterval&& from) noexcept
    : FloatExactOrInterval() {
    *this = ::std::move(from);
  }

  inline FloatExactOrInterval& operator=(FloatExactOrInterval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatExactOrInterval& default_instance();

  enum ExactOrIntervalCase {
    kExact = 1,
    kInterval = 2,
    EXACT_OR_INTERVAL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatExactOrInterval* internal_default_instance() {
    return reinterpret_cast<const FloatExactOrInterval*>(
               &_FloatExactOrInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(FloatExactOrInterval* other);
  friend void swap(FloatExactOrInterval& a, FloatExactOrInterval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatExactOrInterval* New() const final {
    return CreateMaybeMessage<FloatExactOrInterval>(NULL);
  }

  FloatExactOrInterval* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FloatExactOrInterval>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FloatExactOrInterval& from);
  void MergeFrom(const FloatExactOrInterval& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatExactOrInterval* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double exact = 1;
  bool has_exact() const;
  void clear_exact();
  static const int kExactFieldNumber = 1;
  double exact() const;
  void set_exact(double value);

  // optional .commonroad.FloatInterval interval = 2;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 2;
  private:
  const ::commonroad::FloatInterval& _internal_interval() const;
  public:
  const ::commonroad::FloatInterval& interval() const;
  ::commonroad::FloatInterval* release_interval();
  ::commonroad::FloatInterval* mutable_interval();
  void set_allocated_interval(::commonroad::FloatInterval* interval);

  void clear_exact_or_interval();
  ExactOrIntervalCase exact_or_interval_case() const;
  // @@protoc_insertion_point(class_scope:commonroad.FloatExactOrInterval)
 private:
  void set_has_exact();
  void set_has_interval();

  inline bool has_exact_or_interval() const;
  inline void clear_has_exact_or_interval();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ExactOrIntervalUnion {
    ExactOrIntervalUnion() {}
    double exact_;
    ::commonroad::FloatInterval* interval_;
  } exact_or_interval_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IntegerList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.IntegerList) */ {
 public:
  IntegerList();
  virtual ~IntegerList();

  IntegerList(const IntegerList& from);

  inline IntegerList& operator=(const IntegerList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntegerList(IntegerList&& from) noexcept
    : IntegerList() {
    *this = ::std::move(from);
  }

  inline IntegerList& operator=(IntegerList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegerList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntegerList* internal_default_instance() {
    return reinterpret_cast<const IntegerList*>(
               &_IntegerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(IntegerList* other);
  friend void swap(IntegerList& a, IntegerList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntegerList* New() const final {
    return CreateMaybeMessage<IntegerList>(NULL);
  }

  IntegerList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IntegerList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IntegerList& from);
  void MergeFrom(const IntegerList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int32 values(int index) const;
  void set_values(int index, ::google::protobuf::int32 value);
  void add_values(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:commonroad.IntegerList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > values_;
  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FloatList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.FloatList) */ {
 public:
  FloatList();
  virtual ~FloatList();

  FloatList(const FloatList& from);

  inline FloatList& operator=(const FloatList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatList(FloatList&& from) noexcept
    : FloatList() {
    *this = ::std::move(from);
  }

  inline FloatList& operator=(FloatList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatList* internal_default_instance() {
    return reinterpret_cast<const FloatList*>(
               &_FloatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FloatList* other);
  friend void swap(FloatList& a, FloatList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatList* New() const final {
    return CreateMaybeMessage<FloatList>(NULL);
  }

  FloatList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FloatList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FloatList& from);
  void MergeFrom(const FloatList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int32 values(int index) const;
  void set_values(int index, ::google::protobuf::int32 value);
  void add_values(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:commonroad.FloatList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > values_;
  friend struct ::protobuf_util_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TimeStamp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:commonroad.TimeStamp) */ {
 public:
  TimeStamp();
  virtual ~TimeStamp();

  TimeStamp(const TimeStamp& from);

  inline TimeStamp& operator=(const TimeStamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeStamp(TimeStamp&& from) noexcept
    : TimeStamp() {
    *this = ::std::move(from);
  }

  inline TimeStamp& operator=(TimeStamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeStamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeStamp* internal_default_instance() {
    return reinterpret_cast<const TimeStamp*>(
               &_TimeStamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(TimeStamp* other);
  friend void swap(TimeStamp& a, TimeStamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeStamp* New() const final {
    return CreateMaybeMessage<TimeStamp>(NULL);
  }

  TimeStamp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TimeStamp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TimeStamp& from);
  void MergeFrom(const TimeStamp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeStamp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 year = 1;
  bool has_year() const;
  void clear_year();
  static const int kYearFieldNumber = 1;
  ::google::protobuf::uint32 year() const;
  void set_year(::google::protobuf::uint32 value);

  // optional uint32 month = 2;
  bool has_month() const;
  void clear_month();
  static const int kMonthFieldNumber = 2;
  ::google::protobuf::uint32 month() const;
  void set_month(::google::protobuf::uint32 value);

  // optional uint32 day = 3;
  bool has_day() const;
  void clear_day();
  static const int kDayFieldNumber = 3;
  ::google::protobuf::uint32 day() const;
  void set_day(::google::protobuf::uint32 value);

  // optional uint32 hour = 4;
  bool has_hour() const;
  void clear_hour();
  static const int kHourFieldNumber = 4;
  ::google::protobuf::uint32 hour() const;
  void set_hour(::google::protobuf::uint32 value);

  // optional uint32 minute = 5;
  bool has_minute() const;
  void clear_minute();
  static const int kMinuteFieldNumber = 5;
  ::google::protobuf::uint32 minute() const;
  void set_minute(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:commonroad.TimeStamp)
 private:
  void set_has_year();
  void clear_has_year();
  void set_has_month();
  void clear_has_month();
  void set_has_day();
  void clear_has_day();
  void set_has_hour();
  void clear_has_hour();
  void set_has_minute();
  void clear_has_minute();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 year_;
  ::google::protobuf::uint32 month_;
  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 hour_;
  ::google::protobuf::uint32 minute_;
  friend struct ::protobuf_util_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// required double x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:commonroad.Point.x)
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Point.x)
}

// required double y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:commonroad.Point.y)
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Point.y)
}

// -------------------------------------------------------------------

// Rectangle

// required double length = 1;
inline bool Rectangle::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rectangle::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rectangle::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rectangle::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline double Rectangle::length() const {
  // @@protoc_insertion_point(field_get:commonroad.Rectangle.length)
  return length_;
}
inline void Rectangle::set_length(double value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Rectangle.length)
}

// required double width = 2;
inline bool Rectangle::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rectangle::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rectangle::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rectangle::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double Rectangle::width() const {
  // @@protoc_insertion_point(field_get:commonroad.Rectangle.width)
  return width_;
}
inline void Rectangle::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Rectangle.width)
}

// optional .commonroad.Point center = 3;
inline bool Rectangle::has_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rectangle::set_has_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rectangle::clear_has_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rectangle::clear_center() {
  if (center_ != NULL) center_->Clear();
  clear_has_center();
}
inline const ::commonroad::Point& Rectangle::_internal_center() const {
  return *center_;
}
inline const ::commonroad::Point& Rectangle::center() const {
  const ::commonroad::Point* p = center_;
  // @@protoc_insertion_point(field_get:commonroad.Rectangle.center)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::Point*>(
      &::commonroad::_Point_default_instance_);
}
inline ::commonroad::Point* Rectangle::release_center() {
  // @@protoc_insertion_point(field_release:commonroad.Rectangle.center)
  clear_has_center();
  ::commonroad::Point* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::commonroad::Point* Rectangle::mutable_center() {
  set_has_center();
  if (center_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::Point>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Rectangle.center)
  return center_;
}
inline void Rectangle::set_allocated_center(::commonroad::Point* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_;
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    set_has_center();
  } else {
    clear_has_center();
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:commonroad.Rectangle.center)
}

// optional double orientation = 4;
inline bool Rectangle::has_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rectangle::set_has_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rectangle::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rectangle::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline double Rectangle::orientation() const {
  // @@protoc_insertion_point(field_get:commonroad.Rectangle.orientation)
  return orientation_;
}
inline void Rectangle::set_orientation(double value) {
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Rectangle.orientation)
}

// -------------------------------------------------------------------

// Circle

// required double radius = 1;
inline bool Circle::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Circle::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Circle::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Circle::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double Circle::radius() const {
  // @@protoc_insertion_point(field_get:commonroad.Circle.radius)
  return radius_;
}
inline void Circle::set_radius(double value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:commonroad.Circle.radius)
}

// optional .commonroad.Point center = 2;
inline bool Circle::has_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Circle::set_has_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Circle::clear_has_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Circle::clear_center() {
  if (center_ != NULL) center_->Clear();
  clear_has_center();
}
inline const ::commonroad::Point& Circle::_internal_center() const {
  return *center_;
}
inline const ::commonroad::Point& Circle::center() const {
  const ::commonroad::Point* p = center_;
  // @@protoc_insertion_point(field_get:commonroad.Circle.center)
  return p != NULL ? *p : *reinterpret_cast<const ::commonroad::Point*>(
      &::commonroad::_Point_default_instance_);
}
inline ::commonroad::Point* Circle::release_center() {
  // @@protoc_insertion_point(field_release:commonroad.Circle.center)
  clear_has_center();
  ::commonroad::Point* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::commonroad::Point* Circle::mutable_center() {
  set_has_center();
  if (center_ == NULL) {
    auto* p = CreateMaybeMessage<::commonroad::Point>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Circle.center)
  return center_;
}
inline void Circle::set_allocated_center(::commonroad::Point* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_;
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    set_has_center();
  } else {
    clear_has_center();
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:commonroad.Circle.center)
}

// -------------------------------------------------------------------

// Polygon

// repeated .commonroad.Point vertices = 1;
inline int Polygon::vertices_size() const {
  return vertices_.size();
}
inline void Polygon::clear_vertices() {
  vertices_.Clear();
}
inline ::commonroad::Point* Polygon::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:commonroad.Polygon.vertices)
  return vertices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::commonroad::Point >*
Polygon::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:commonroad.Polygon.vertices)
  return &vertices_;
}
inline const ::commonroad::Point& Polygon::vertices(int index) const {
  // @@protoc_insertion_point(field_get:commonroad.Polygon.vertices)
  return vertices_.Get(index);
}
inline ::commonroad::Point* Polygon::add_vertices() {
  // @@protoc_insertion_point(field_add:commonroad.Polygon.vertices)
  return vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::commonroad::Point >&
Polygon::vertices() const {
  // @@protoc_insertion_point(field_list:commonroad.Polygon.vertices)
  return vertices_;
}

// -------------------------------------------------------------------

// ShapeGroup

// repeated .commonroad.Shape shapes = 1;
inline int ShapeGroup::shapes_size() const {
  return shapes_.size();
}
inline void ShapeGroup::clear_shapes() {
  shapes_.Clear();
}
inline ::commonroad::Shape* ShapeGroup::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:commonroad.ShapeGroup.shapes)
  return shapes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::commonroad::Shape >*
ShapeGroup::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:commonroad.ShapeGroup.shapes)
  return &shapes_;
}
inline const ::commonroad::Shape& ShapeGroup::shapes(int index) const {
  // @@protoc_insertion_point(field_get:commonroad.ShapeGroup.shapes)
  return shapes_.Get(index);
}
inline ::commonroad::Shape* ShapeGroup::add_shapes() {
  // @@protoc_insertion_point(field_add:commonroad.ShapeGroup.shapes)
  return shapes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::commonroad::Shape >&
ShapeGroup::shapes() const {
  // @@protoc_insertion_point(field_list:commonroad.ShapeGroup.shapes)
  return shapes_;
}

// -------------------------------------------------------------------

// Shape

// optional .commonroad.Rectangle rectangle = 1;
inline bool Shape::has_rectangle() const {
  return shape_case() == kRectangle;
}
inline void Shape::set_has_rectangle() {
  _oneof_case_[0] = kRectangle;
}
inline void Shape::clear_rectangle() {
  if (has_rectangle()) {
    delete shape_.rectangle_;
    clear_has_shape();
  }
}
inline const ::commonroad::Rectangle& Shape::_internal_rectangle() const {
  return *shape_.rectangle_;
}
inline ::commonroad::Rectangle* Shape::release_rectangle() {
  // @@protoc_insertion_point(field_release:commonroad.Shape.rectangle)
  if (has_rectangle()) {
    clear_has_shape();
      ::commonroad::Rectangle* temp = shape_.rectangle_;
    shape_.rectangle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::commonroad::Rectangle& Shape::rectangle() const {
  // @@protoc_insertion_point(field_get:commonroad.Shape.rectangle)
  return has_rectangle()
      ? *shape_.rectangle_
      : *reinterpret_cast< ::commonroad::Rectangle*>(&::commonroad::_Rectangle_default_instance_);
}
inline ::commonroad::Rectangle* Shape::mutable_rectangle() {
  if (!has_rectangle()) {
    clear_shape();
    set_has_rectangle();
    shape_.rectangle_ = CreateMaybeMessage< ::commonroad::Rectangle >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Shape.rectangle)
  return shape_.rectangle_;
}

// optional .commonroad.Circle circle = 2;
inline bool Shape::has_circle() const {
  return shape_case() == kCircle;
}
inline void Shape::set_has_circle() {
  _oneof_case_[0] = kCircle;
}
inline void Shape::clear_circle() {
  if (has_circle()) {
    delete shape_.circle_;
    clear_has_shape();
  }
}
inline const ::commonroad::Circle& Shape::_internal_circle() const {
  return *shape_.circle_;
}
inline ::commonroad::Circle* Shape::release_circle() {
  // @@protoc_insertion_point(field_release:commonroad.Shape.circle)
  if (has_circle()) {
    clear_has_shape();
      ::commonroad::Circle* temp = shape_.circle_;
    shape_.circle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::commonroad::Circle& Shape::circle() const {
  // @@protoc_insertion_point(field_get:commonroad.Shape.circle)
  return has_circle()
      ? *shape_.circle_
      : *reinterpret_cast< ::commonroad::Circle*>(&::commonroad::_Circle_default_instance_);
}
inline ::commonroad::Circle* Shape::mutable_circle() {
  if (!has_circle()) {
    clear_shape();
    set_has_circle();
    shape_.circle_ = CreateMaybeMessage< ::commonroad::Circle >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Shape.circle)
  return shape_.circle_;
}

// optional .commonroad.Polygon polygon = 3;
inline bool Shape::has_polygon() const {
  return shape_case() == kPolygon;
}
inline void Shape::set_has_polygon() {
  _oneof_case_[0] = kPolygon;
}
inline void Shape::clear_polygon() {
  if (has_polygon()) {
    delete shape_.polygon_;
    clear_has_shape();
  }
}
inline const ::commonroad::Polygon& Shape::_internal_polygon() const {
  return *shape_.polygon_;
}
inline ::commonroad::Polygon* Shape::release_polygon() {
  // @@protoc_insertion_point(field_release:commonroad.Shape.polygon)
  if (has_polygon()) {
    clear_has_shape();
      ::commonroad::Polygon* temp = shape_.polygon_;
    shape_.polygon_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::commonroad::Polygon& Shape::polygon() const {
  // @@protoc_insertion_point(field_get:commonroad.Shape.polygon)
  return has_polygon()
      ? *shape_.polygon_
      : *reinterpret_cast< ::commonroad::Polygon*>(&::commonroad::_Polygon_default_instance_);
}
inline ::commonroad::Polygon* Shape::mutable_polygon() {
  if (!has_polygon()) {
    clear_shape();
    set_has_polygon();
    shape_.polygon_ = CreateMaybeMessage< ::commonroad::Polygon >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Shape.polygon)
  return shape_.polygon_;
}

// optional .commonroad.ShapeGroup shape_group = 4;
inline bool Shape::has_shape_group() const {
  return shape_case() == kShapeGroup;
}
inline void Shape::set_has_shape_group() {
  _oneof_case_[0] = kShapeGroup;
}
inline void Shape::clear_shape_group() {
  if (has_shape_group()) {
    delete shape_.shape_group_;
    clear_has_shape();
  }
}
inline const ::commonroad::ShapeGroup& Shape::_internal_shape_group() const {
  return *shape_.shape_group_;
}
inline ::commonroad::ShapeGroup* Shape::release_shape_group() {
  // @@protoc_insertion_point(field_release:commonroad.Shape.shape_group)
  if (has_shape_group()) {
    clear_has_shape();
      ::commonroad::ShapeGroup* temp = shape_.shape_group_;
    shape_.shape_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::commonroad::ShapeGroup& Shape::shape_group() const {
  // @@protoc_insertion_point(field_get:commonroad.Shape.shape_group)
  return has_shape_group()
      ? *shape_.shape_group_
      : *reinterpret_cast< ::commonroad::ShapeGroup*>(&::commonroad::_ShapeGroup_default_instance_);
}
inline ::commonroad::ShapeGroup* Shape::mutable_shape_group() {
  if (!has_shape_group()) {
    clear_shape();
    set_has_shape_group();
    shape_.shape_group_ = CreateMaybeMessage< ::commonroad::ShapeGroup >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:commonroad.Shape.shape_group)
  return shape_.shape_group_;
}

inline bool Shape::has_shape() const {
  return shape_case() != SHAPE_NOT_SET;
}
inline void Shape::clear_has_shape() {
  _oneof_case_[0] = SHAPE_NOT_SET;
}
inline Shape::ShapeCase Shape::shape_case() const {
  return Shape::ShapeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// IntegerInterval

// required int32 start = 1;
inline bool IntegerInterval::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntegerInterval::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntegerInterval::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntegerInterval::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 IntegerInterval::start() const {
  // @@protoc_insertion_point(field_get:commonroad.IntegerInterval.start)
  return start_;
}
inline void IntegerInterval::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:commonroad.IntegerInterval.start)
}

// required int32 end = 2;
inline bool IntegerInterval::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntegerInterval::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntegerInterval::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntegerInterval::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 IntegerInterval::end() const {
  // @@protoc_insertion_point(field_get:commonroad.IntegerInterval.end)
  return end_;
}
inline void IntegerInterval::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:commonroad.IntegerInterval.end)
}

// -------------------------------------------------------------------

// FloatInterval

// required double start = 1;
inline bool FloatInterval::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatInterval::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloatInterval::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloatInterval::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline double FloatInterval::start() const {
  // @@protoc_insertion_point(field_get:commonroad.FloatInterval.start)
  return start_;
}
inline void FloatInterval::set_start(double value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:commonroad.FloatInterval.start)
}

// required double end = 2;
inline bool FloatInterval::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloatInterval::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloatInterval::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloatInterval::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline double FloatInterval::end() const {
  // @@protoc_insertion_point(field_get:commonroad.FloatInterval.end)
  return end_;
}
inline void FloatInterval::set_end(double value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:commonroad.FloatInterval.end)
}

// -------------------------------------------------------------------

// IntegerExactOrInterval

// optional int32 exact = 1;
inline bool IntegerExactOrInterval::has_exact() const {
  return exact_or_interval_case() == kExact;
}
inline void IntegerExactOrInterval::set_has_exact() {
  _oneof_case_[0] = kExact;
}
inline void IntegerExactOrInterval::clear_exact() {
  if (has_exact()) {
    exact_or_interval_.exact_ = 0;
    clear_has_exact_or_interval();
  }
}
inline ::google::protobuf::int32 IntegerExactOrInterval::exact() const {
  // @@protoc_insertion_point(field_get:commonroad.IntegerExactOrInterval.exact)
  if (has_exact()) {
    return exact_or_interval_.exact_;
  }
  return 0;
}
inline void IntegerExactOrInterval::set_exact(::google::protobuf::int32 value) {
  if (!has_exact()) {
    clear_exact_or_interval();
    set_has_exact();
  }
  exact_or_interval_.exact_ = value;
  // @@protoc_insertion_point(field_set:commonroad.IntegerExactOrInterval.exact)
}

// optional .commonroad.IntegerInterval interval = 2;
inline bool IntegerExactOrInterval::has_interval() const {
  return exact_or_interval_case() == kInterval;
}
inline void IntegerExactOrInterval::set_has_interval() {
  _oneof_case_[0] = kInterval;
}
inline void IntegerExactOrInterval::clear_interval() {
  if (has_interval()) {
    delete exact_or_interval_.interval_;
    clear_has_exact_or_interval();
  }
}
inline const ::commonroad::IntegerInterval& IntegerExactOrInterval::_internal_interval() const {
  return *exact_or_interval_.interval_;
}
inline ::commonroad::IntegerInterval* IntegerExactOrInterval::release_interval() {
  // @@protoc_insertion_point(field_release:commonroad.IntegerExactOrInterval.interval)
  if (has_interval()) {
    clear_has_exact_or_interval();
      ::commonroad::IntegerInterval* temp = exact_or_interval_.interval_;
    exact_or_interval_.interval_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::commonroad::IntegerInterval& IntegerExactOrInterval::interval() const {
  // @@protoc_insertion_point(field_get:commonroad.IntegerExactOrInterval.interval)
  return has_interval()
      ? *exact_or_interval_.interval_
      : *reinterpret_cast< ::commonroad::IntegerInterval*>(&::commonroad::_IntegerInterval_default_instance_);
}
inline ::commonroad::IntegerInterval* IntegerExactOrInterval::mutable_interval() {
  if (!has_interval()) {
    clear_exact_or_interval();
    set_has_interval();
    exact_or_interval_.interval_ = CreateMaybeMessage< ::commonroad::IntegerInterval >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:commonroad.IntegerExactOrInterval.interval)
  return exact_or_interval_.interval_;
}

inline bool IntegerExactOrInterval::has_exact_or_interval() const {
  return exact_or_interval_case() != EXACT_OR_INTERVAL_NOT_SET;
}
inline void IntegerExactOrInterval::clear_has_exact_or_interval() {
  _oneof_case_[0] = EXACT_OR_INTERVAL_NOT_SET;
}
inline IntegerExactOrInterval::ExactOrIntervalCase IntegerExactOrInterval::exact_or_interval_case() const {
  return IntegerExactOrInterval::ExactOrIntervalCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FloatExactOrInterval

// optional double exact = 1;
inline bool FloatExactOrInterval::has_exact() const {
  return exact_or_interval_case() == kExact;
}
inline void FloatExactOrInterval::set_has_exact() {
  _oneof_case_[0] = kExact;
}
inline void FloatExactOrInterval::clear_exact() {
  if (has_exact()) {
    exact_or_interval_.exact_ = 0;
    clear_has_exact_or_interval();
  }
}
inline double FloatExactOrInterval::exact() const {
  // @@protoc_insertion_point(field_get:commonroad.FloatExactOrInterval.exact)
  if (has_exact()) {
    return exact_or_interval_.exact_;
  }
  return 0;
}
inline void FloatExactOrInterval::set_exact(double value) {
  if (!has_exact()) {
    clear_exact_or_interval();
    set_has_exact();
  }
  exact_or_interval_.exact_ = value;
  // @@protoc_insertion_point(field_set:commonroad.FloatExactOrInterval.exact)
}

// optional .commonroad.FloatInterval interval = 2;
inline bool FloatExactOrInterval::has_interval() const {
  return exact_or_interval_case() == kInterval;
}
inline void FloatExactOrInterval::set_has_interval() {
  _oneof_case_[0] = kInterval;
}
inline void FloatExactOrInterval::clear_interval() {
  if (has_interval()) {
    delete exact_or_interval_.interval_;
    clear_has_exact_or_interval();
  }
}
inline const ::commonroad::FloatInterval& FloatExactOrInterval::_internal_interval() const {
  return *exact_or_interval_.interval_;
}
inline ::commonroad::FloatInterval* FloatExactOrInterval::release_interval() {
  // @@protoc_insertion_point(field_release:commonroad.FloatExactOrInterval.interval)
  if (has_interval()) {
    clear_has_exact_or_interval();
      ::commonroad::FloatInterval* temp = exact_or_interval_.interval_;
    exact_or_interval_.interval_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::commonroad::FloatInterval& FloatExactOrInterval::interval() const {
  // @@protoc_insertion_point(field_get:commonroad.FloatExactOrInterval.interval)
  return has_interval()
      ? *exact_or_interval_.interval_
      : *reinterpret_cast< ::commonroad::FloatInterval*>(&::commonroad::_FloatInterval_default_instance_);
}
inline ::commonroad::FloatInterval* FloatExactOrInterval::mutable_interval() {
  if (!has_interval()) {
    clear_exact_or_interval();
    set_has_interval();
    exact_or_interval_.interval_ = CreateMaybeMessage< ::commonroad::FloatInterval >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:commonroad.FloatExactOrInterval.interval)
  return exact_or_interval_.interval_;
}

inline bool FloatExactOrInterval::has_exact_or_interval() const {
  return exact_or_interval_case() != EXACT_OR_INTERVAL_NOT_SET;
}
inline void FloatExactOrInterval::clear_has_exact_or_interval() {
  _oneof_case_[0] = EXACT_OR_INTERVAL_NOT_SET;
}
inline FloatExactOrInterval::ExactOrIntervalCase FloatExactOrInterval::exact_or_interval_case() const {
  return FloatExactOrInterval::ExactOrIntervalCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// IntegerList

// repeated int32 values = 1;
inline int IntegerList::values_size() const {
  return values_.size();
}
inline void IntegerList::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int32 IntegerList::values(int index) const {
  // @@protoc_insertion_point(field_get:commonroad.IntegerList.values)
  return values_.Get(index);
}
inline void IntegerList::set_values(int index, ::google::protobuf::int32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:commonroad.IntegerList.values)
}
inline void IntegerList::add_values(::google::protobuf::int32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:commonroad.IntegerList.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
IntegerList::values() const {
  // @@protoc_insertion_point(field_list:commonroad.IntegerList.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
IntegerList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:commonroad.IntegerList.values)
  return &values_;
}

// -------------------------------------------------------------------

// FloatList

// repeated int32 values = 1;
inline int FloatList::values_size() const {
  return values_.size();
}
inline void FloatList::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int32 FloatList::values(int index) const {
  // @@protoc_insertion_point(field_get:commonroad.FloatList.values)
  return values_.Get(index);
}
inline void FloatList::set_values(int index, ::google::protobuf::int32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:commonroad.FloatList.values)
}
inline void FloatList::add_values(::google::protobuf::int32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:commonroad.FloatList.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FloatList::values() const {
  // @@protoc_insertion_point(field_list:commonroad.FloatList.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FloatList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:commonroad.FloatList.values)
  return &values_;
}

// -------------------------------------------------------------------

// TimeStamp

// optional uint32 year = 1;
inline bool TimeStamp::has_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeStamp::set_has_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeStamp::clear_has_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeStamp::clear_year() {
  year_ = 0u;
  clear_has_year();
}
inline ::google::protobuf::uint32 TimeStamp::year() const {
  // @@protoc_insertion_point(field_get:commonroad.TimeStamp.year)
  return year_;
}
inline void TimeStamp::set_year(::google::protobuf::uint32 value) {
  set_has_year();
  year_ = value;
  // @@protoc_insertion_point(field_set:commonroad.TimeStamp.year)
}

// optional uint32 month = 2;
inline bool TimeStamp::has_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeStamp::set_has_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeStamp::clear_has_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeStamp::clear_month() {
  month_ = 0u;
  clear_has_month();
}
inline ::google::protobuf::uint32 TimeStamp::month() const {
  // @@protoc_insertion_point(field_get:commonroad.TimeStamp.month)
  return month_;
}
inline void TimeStamp::set_month(::google::protobuf::uint32 value) {
  set_has_month();
  month_ = value;
  // @@protoc_insertion_point(field_set:commonroad.TimeStamp.month)
}

// optional uint32 day = 3;
inline bool TimeStamp::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeStamp::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeStamp::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeStamp::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 TimeStamp::day() const {
  // @@protoc_insertion_point(field_get:commonroad.TimeStamp.day)
  return day_;
}
inline void TimeStamp::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:commonroad.TimeStamp.day)
}

// optional uint32 hour = 4;
inline bool TimeStamp::has_hour() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeStamp::set_has_hour() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeStamp::clear_has_hour() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeStamp::clear_hour() {
  hour_ = 0u;
  clear_has_hour();
}
inline ::google::protobuf::uint32 TimeStamp::hour() const {
  // @@protoc_insertion_point(field_get:commonroad.TimeStamp.hour)
  return hour_;
}
inline void TimeStamp::set_hour(::google::protobuf::uint32 value) {
  set_has_hour();
  hour_ = value;
  // @@protoc_insertion_point(field_set:commonroad.TimeStamp.hour)
}

// optional uint32 minute = 5;
inline bool TimeStamp::has_minute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimeStamp::set_has_minute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimeStamp::clear_has_minute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimeStamp::clear_minute() {
  minute_ = 0u;
  clear_has_minute();
}
inline ::google::protobuf::uint32 TimeStamp::minute() const {
  // @@protoc_insertion_point(field_get:commonroad.TimeStamp.minute)
  return minute_;
}
inline void TimeStamp::set_minute(::google::protobuf::uint32 value) {
  set_has_minute();
  minute_ = value;
  // @@protoc_insertion_point(field_set:commonroad.TimeStamp.minute)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commonroad

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_util_2eproto
